[{"title":"同步github-page","date":"2017-12-12T13:55:52.000Z","path":"同步github-page/","text":"起今天才知道github屏蔽了百度的爬虫，因此搭建在github上的个人博客无法被百度索引，上网搜索了方法，发现主要有以下两种。 使用CDN加速 同步发布博客到一个镜像站 第一种方法对访问量大的博客才有作用，于是只能采用第二个方法了。 自动同步镜像站可以使用第三方云平台，也可以自己管理，搭建在云主机上。刚好我在腾讯云上还有台云主机，可以开设一个服务，专用于提供静态博客内容，要解决的问题就是如何与github page的内容保持同步。理想的情况应该是：保持现有的写作方式不变，发布时自动同步到我的云主机上。 如何才能做到这一点呢。 webhookgithub提供了webhook的功能，它可以在指定事件发生后，向指定url发送一个post请求。 github上具体的配置界面如下。使用它我们就能知道代码在什么时候发生了变化。在事件触发时时自动从github拉取代码，更新本地文件内容。我们可以直接在本地开启一个node服务，指定一个路由对应webhook的url，当路由被访问时通过node执行shell命令。这里我采用了另一种方式，使用jenkins这个CI平台。它提供了github插件，支持webhook，同时还有一些额外的功能。我们只需要简单的配置就能自动从github上拉取代码，然后在构建时执行shell命令用于复制文件就能实现想要的效果。 总结其实所有的构建过程都可以通过jenkins来做，包括编译生成静态文件，发布到github等一些列操作，我们要做的只是写markdown，实现真正意义上的自动化。但是因为服务器性能有限，并且一般情况下我们都需要运行本地服务器，先查看下显示效果才会发布。综合考虑之下，只让jenkins承担了一个同步备份的作用。 参考webhook自动部署","tags":[{"name":"综合","slug":"综合","permalink":"http://realwate.com/tags/综合/"}]},{"title":"设置元素的可访问性","date":"2017-12-09T06:02:05.000Z","path":"设置元素的可访问性/","text":"隐藏一个元素有多种方式 常用属性及差异 参考css-tricks","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"},{"name":"CSS","slug":"CSS","permalink":"http://realwate.com/tags/CSS/"}]},{"title":"table的布局算法","date":"2017-12-09T04:52:34.000Z","path":"table的布局算法/","text":"起使用table时发现td中存在大段文字且没有break-word的情况下，给td设置的固定宽度无效，于是有了这篇文章。 table-layouttable-layout 属性定义了用于布局表格单元格，行和列的算法。它有以下两个值。 auto浏览器默认的算法。表格及单元格的宽度取决于其包含的内容。使用auto算法的table，我们设置的cell大小只是理想宽度，浏览器会尽量满足我们设置的宽度，但实际显示的宽度还是由内容决定，内容一定被包裹在td中。 使用该算法时，浏览器会遍历整个table，计算合适的宽度，使所有的td都能完整容纳内容， fixed表格的布局由且仅由第一行也就是第一个tr元素决定如果第一行没有设置任何宽度，那么无论单元格内的内容如何，列的宽度在表中平均分配。 使用 fixed 布局方式时，整个表格可以在其首行被下载后就被解析和渲染。 例子有以下html和CSS 123456789101112131415161718192021222324252627282930&lt;div class=\"w\"&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th style=\"width: 100px\"&gt; 宽度设置了100px This is very longlonglonglonglonglonglonglonglong &lt;/th&gt; &lt;th&gt;bbbb&lt;/th&gt; &lt;th&gt;c&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;3&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt; 123456789101112131415 *&#123; padding: 0; margin: 0; &#125;.w&#123; width: 400px; padding: 10px;&#125; table&#123; width: 100%; border-collapse: collapse; &#125; td,th&#123; border:1px solid #888; &#125; 结果table-layout:auto table-layout:fixed 总结使用table-layout:fixed；算法的表格渲染更快，因为浏览器只要知道第一行的内容就能确定整个表格的布局。 而auto算法需要遍历整个table分析他们的内容，使得最终渲染出来的每个单元格都完整容纳着内容。如果我们的单元格宽度是固定的，应该使用fixed算法而不是默认的auto。 参考css-tricks.MDN","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"},{"name":"CSS","slug":"CSS","permalink":"http://realwate.com/tags/CSS/"}]},{"title":"块级作用域函数声明","date":"2017-12-02T08:48:36.000Z","path":"块级作用域函数声明/","text":"起起源于segmentfault上的一个问题，有如下代码。 12345678910111213function f()&#123; console.log('I am outside!');&#125;(function ()&#123; if (false)&#123; function f()&#123; console.log('I am inside!'); &#125; &#125; f();&#125;()) 按照我的理解，函数声明会提升到所在函数作用域的顶部，真正执行的代码应该是下面这段。12345678function f() &#123; console.log('I am outside!'); &#125;(function () &#123;function f() &#123; console.log('I am inside!'); &#125; if (false) &#123; &#125; f(); // 结果应该是`inside`。&#125;()); 当我复制这段代码在chrome 62.0下执行时，却得到了如下结果。难以理解，按照正常的逻辑，怎么说不是输出inside也该是outside吧。 解这段代码是出自阮一峰老师所著的ECMAScript 6 入门，原文其实已经有不错的解释，这里按照我的理解在梳理一下。 IIFE在segmentfault上，有人提出括号有问题，正确的IIFE写法应该是如下这种1(function()&#123;&#125;)() 但是实际上两种写法作用是一样的。圆括号(The grouping operator)是用来控制表达式中的运算优先级，也就是说它只能包含表达式。在有些上下文中我们需要的是一个表达式，而代码却可能解析成语句或产生其他歧义，这个时候我们可以使用圆括号让它被当作表达式处理。 如以下写法就会出错12var json = JSON.stringify(&#123;\"a\":\"a\"&#125;);eval(json); // &#123;&#125;被认为是block 正确写法如下12var json = JSON.stringify(&#123;\"a\":\"a\"&#125;);eval('(' + json + ')') IIFE的写法有很多种1234(function foo()&#123;&#125;());(function foo()&#123;&#125;)();!function foo()&#123;&#125;();~function foo()&#123;&#125;(); 基本上都是为了使引擎将其当作表达式处理。 块级作用域在es6之前js只能通过var定义变量，var是没有块级作用域的概念，只有全局作用域与函数作用域。es6中，使用 let和const声明的变量具有块级作用域，同时变量提升规则也发生了一些变化，具体可查看这篇文章。相应的，随着标准的演变，块级函数声明的语义也产生了一些变化。 ES5ES5时期，标准规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。但是大多数浏览器实现没有遵循，在”所有地方”的函数声明都是合法的，它们扩展了标准的语义。上面那段代码等同于123456789//es5 sloppy modefunction f() &#123; console.log('I am outside!'); &#125;(function () &#123;function f() &#123; console.log('I am inside!'); &#125; if (false) &#123; &#125; f(); // 输出inside&#125;()); 但是，实际上这是一个让人容易产生困惑的特性，因此，在es5严格模式下，禁止了不在脚本或者函数层面上的函数声明。MDN有提到这一点。 ES6到了es6，标准允许在块级作用域的函数声明，块级作用域内声明的函数类似于let。但是浏览器实现为了兼容性，只有启用了严格模式，行为才会同标准一致。1234567891011// es6 strictfunction f() &#123; console.log('I am outside!'); &#125;(function () &#123; \"use strict\"; if (false) &#123; // 重复声明一次函数f let f = function() &#123; console.log('I am inside!'); &#125; // 相当于let 不会影响外部 &#125; f(); // outside&#125;()); 在普通模式下的行为有些复杂，执行的会是如下代码。123456789// es6 sloppy mode(function () &#123; var f; // f类似于var，会提升到全局作用域或函数作用域的顶部。 if (false) &#123; f = function() &#123; console.log('I am inside!'); &#125; // 函数声明只会提升到所在的块级作用域的顶部。 &#125; f(); // f为undefined&#125;()); 这也正是产生TypeError的原因。 总结stackoverflow上Bergi的回答已经总结的很好了。 总的来说，块级作用域函数声明随着标准的发展语义已经产生了一些变化，而浏览器为了所谓的兼容性也会与规范有出入。其实，这些本质上都是javascript先天设计不足后天弥补的体现，我们如果知道了这样的一个过程，自然也就理解了。","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"},{"name":"javascript","slug":"javascript","permalink":"http://realwate.com/tags/javascript/"}]},{"title":"使用chrome分析内存问题","date":"2017-11-26T06:17:40.000Z","path":"使用chrome分析内存问题/","text":"Chrome DevTools提供了强大的工具帮助我们分析内存问题，让我们来看下如何使用。 内存管理算法手动管理如C语言、C++中，使用 malloc/new 分配的内存必须手动调用 free/delete 才能释放内存，使用不当就可能出现内存泄漏。 自动管理也就是通常说的垃圾回收(GC)，主要有两种实现。 引用计数算法对象会关联到一个引用计数器， 每当创建一个新的引用指向该对象时其计数器就加1，指向该对象的引用失效时计数器就减1。计数器变为0就认为对象死亡，释放内存。最基本的纯引用计数方式可以做到实时释放死对象，但却无法处理存在循环引用的对象图的释放。 可达性算法从GC Roots作为起点开始搜索，所有能达到的对象都是活对象，无法到达的对象便成了垃圾回收的对象。基本的算法有标记清除算法(mark and sweep)，执行时分为两个阶段 标记过程：遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象 清除过程：遍历堆中所有的对象，将没有标记的对象清除，释放内存 大多数语言使用的算法都是基于标记清除算法。关于GC的讨论，可以看知乎的这两个问题1 2，浏览器上的内存管理可查看MDN chrome分析内存使用 Chrome DevTools能够帮助我们查找影响页面性能的内存问题，包括内存泄漏、内存膨胀和频繁的垃圾回收。 任务管理器按 Shift+Esc ，右键点击任务管理器的表格标题并启用 JavaScript memory，效果如下。 Memory 列表示原生内存。DOM节点存储在原生内存中。 如果此值正在增大，则说明正在创建 DOM 节点。JavaScript Memory 列表示 JS 堆。我们只需要关注括号中的实时数字，它表示页面上的可到达对象正在使用的内存量。如果此数字在增大，要么是正在创建新对象，要么是现有对象正在增长。 Timeline新版Chrome timeline放到了performance中，一般timeline是用来分析页面的加载、渲染情况的，勾上memory复选框后，就可以查看内存的变化了。它们按类别分为 JS 堆 、文档、DOM 节点、事件监听器和 GPU。 MemoryMemory 面板提供了更为详细的内存信息，heap snapshot能查看全局的内存分配，allocation timeline可根据时间查看，record allocation profile按照函数来查看。 heap snapshot Shallow Size 是指对象自身占用的内存大小（一般来说，数组和字符串的浅层大小比较大）,不包含它引用的那些对象空间。 Retained Size 表示该对象删除后（其依赖项不再可到达）可以释放的内存大小，称为保留大小。、 @ 字符后面的数字是对象的唯一 ID，可以使用此 ID 以对象为基础比较堆快照。 Retainers视图显示该对象被哪些对象引用了，以及这个引用的名称。 黄色突出显示的节点具有 JavaScript 代码对它们的直接引用。 以红色突出显示的节点则没有直接引用。 默认显示的是summary视图，还可以显示两个快照之间的差异。 在# New列里，如果有.，则表示是新建的对象。 在# Deleted列里，如果有.，则表示是回收了的对象。 allocation timeline按照时间线显示内存的分配记录。 record allocation profile按函数显示内存分配明细。默认视图为 Heavy (Bottom Up)，将分配了最多内存的函数显示在最上方。 总结如果感觉页面经常暂停，则可能存在垃圾回收问题。可以使用 Chrome 任务管理器或者 Timeline 内存记录发现频繁的垃圾回收。 在任务管理器中，Memory 或 JavaScript Memory 值频繁上升和下降表示存在频繁的垃圾回收。在 Timeline 记录中，JS 堆或节点计数图表频繁上升和下降指示存在频繁的垃圾回收。确定问题后，再使用Memory面板中的功能查看更详细的内存分配情况。 参考官方文档其他","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"}]},{"title":"面向对象思考和设计原则","date":"2017-11-23T12:00:16.000Z","path":"面向对象思考和设计原则/","text":"起面向对象编程是我们常用的一种编程范式，我学习的第一门OOP语言是C++,从那以后接触到的语言基本上都能跟OOP扯上关系。刚接触时，简单的理解面向对象就是把对象的属性及相关行为进行封装。到今天，过去了三年，我尝试从软件工程的角度再次理解面向对象给我们带来的好处，以及基于此的一些设计原则。 封装封装使得类具有良好的扩展性。它隐藏繁琐的细节，只暴露必要的接口。在不改变原有接口情况下，我们可以任意改变这个类的实现细节而不用担心会影响到其它类。 继承继承使得代码能够复用。常与继承作比较的就是组合了，有很多人认为组合优于继承，复用时要尽量使用组合，少用继承。这种说法有一定道理，继承作为代码复用的一种手段，实际上是存在问题的 使用继承时，子类可能知道父类实现的细节(protected)，破坏了父类的封装性 子类只能依赖于具体的父类实现，本身的耦合程度很高，父类接口的任何变化，都可能导致子类的改变 滥用继承会出现类爆炸，增加系统结构的复杂度 组合的目的也是为了代码复用，相比继承，组合只会也只能知道使用类公开的接口，同时，组合可以接受接口、抽象类等抽象类型而不要求是具体实现，更加灵活。 个人认为，我们使用继承的目的一般是为了服务于多态。 多态在运行时，同一个接口调用能绑定到不同的子类，继而产生不同的结果。具体的行为由实现类决定，这是我们写出弹性代码的关键。它本质上是一种动态绑定技术。在C++中要使用virtual关键字修饰并且通过子类的指针或引用来访问时才产生多态，JAVA则默认所有的方法都是动态绑定的。 面向对象设计原则要减少数据库的冗余程度，可以通过范式的指导，而如果要编写高质量的代码，就需要参考这些设计原则了。基本的面向对象设计原则有七种，它们为支持软件的可维护性、可复用性而诞生，蕴含在很多设计模式中。 面向接口编程在程序中依赖于一种约定，协议来编程，而不是具体的某个对象。这种留有弹性的设计为系统的扩展提供可能。这鼓励我们在代码中尽量使用抽象层进行编程，当需求发生变化时，只需修改或替换实现类就能扩展系统的功能。 职责分离简单的说就是一个类一个责任，类的目的要纯粹。一个类承担的职责越多，复用的可能性就越小。同时，过多的职责耦合在一起，当其中一个职责变化时，可能会影响其他职责。这鼓励我们在编码中将类、函数等都拆得细一点，利于代码的复用。 开闭原则对扩展开放，对修改关闭。开闭原则是我们要达到的目标，即软件实体应尽量在不修改原有代码的情况下进行扩展。满足了开闭原则的系统拥有良好的扩展性。 好莱坞原则不要联系我，我会联系你。在框架设计中很多地方都用到，如依赖注入使得我们不需要主动再new一个对象，而是写在配置文件中由依赖注入框架管理。又或者模板方法设计模式中，上层类定义了算法的步骤，子类只需要提供实现，由父类自动调用。 迪米特原则不要和陌生人说话。尽量减少类与类之间的耦合度，这样当其中一个变化时，能尽量少地影响到其他模块，扩展变得容易。 总结 Computer Science is the discipline that believes all problems can be solved with one more layer of indirection.计算机科学是这样一门学科：它相信所有的问题都能通过增加一个中间层来解决。 第一次知道这句话是在《程序员的自我修养》这本书中，随着眼界的开阔，越发觉得这句话是个万能法则。从计算机底层、通信协议，到软件架构、编码技巧等，很多问题都能通过增加一个中间层来解决。设计模式中的很多思路也是这样，我们不希望面向具体编程，所以我们针对抽象层编程，我们不希望类与类之间过度耦合，所以抽出一个中介者来，我们希望实现代码的复用，所以将类的粒度抽的足够细…我想，我还会继续并且持久的领悟这句话吧。","tags":[{"name":"综合","slug":"综合","permalink":"http://realwate.com/tags/综合/"}]},{"title":"正则表达式总结","date":"2017-11-22T12:13:04.000Z","path":"正则表达式总结/","text":"概念首先明确概念：正则是一种匹配模式，要么匹配字符，要么匹配位置。基于匹配，我们便可以做很多事情，如查找、分割、替换等 横向模糊匹配限制匹配的字符出现的次数，称为量词或重复123var regex = /a&#123;2,3&#125;b/; //a出现的次数在[2,3]regex.test(\"aab\") // trueregex.test(\"aaab\") // true 特殊的有以下简写 {m,} 表示至少出现m次 {m} 等价于{m,m}，表示出现m次 ? 等价于{0,1} + 等价于{1,} * 等价于{0,}，表示出现任意次，有可能不出现 默认所有的量词都是贪婪的，它会在满足整体匹配的情况下，尽量使局部匹配更多的字符。若存在连续的贪婪匹配，会优先满足先出现的。如果要使用非贪婪匹配也就是惰性匹配，在后面加个?就行了，如{m,n}?,+? 纵向模糊匹配用于匹配某一类字符,包括字符组和分支 字符组匹配的字符在[]内123var regex = /[a-z]*/; //匹配小写字母regex.test(\"1\") //falseregex.test(\"a\") //true tips在字符组中使用 - 表示范围， ^表示取反 分支简单的条件选择,理解为逻辑上的或123var regex = /\\d|[a-z]/; //匹配数字 或 小写字母regex.test(\"+\") // falseregex.test(\"3\") // true tips| 优先级最低，使用时要注意，如/^\\d|[a-z]$/ 不同于 /^(\\d|[a-z])$/ 常用简写 \\d : digit。等价于[0-9]，表示是一位数字。\\D就是[^0-9] \\w : word。等价于[0-9a-zA-Z_]。表示数字、大小写字母和下划线 \\W是[^0-9a-zA-Z_] \\s : space。等价于[ \\t\\v\\n\\r\\f]。表示空白符，包括空格、水平制表符、回车符等。\\S是[^ \\t\\v\\n\\r\\f] . : 通配符。等价于[^\\n\\r\\u2028\\u2029]。表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外 匹配位置位置的匹配与字符略有不同，一个字符，同一时间只能由一个子表达式匹配，而一个位置，却可以同时由多个零宽度的子表达式匹配。12/(?=1)(?=2)/.test(\"12\") // false// 这样的表达式是匹配失败的 因为它匹配到一个位置 这个位置的后面既是1 又是2 显然是不存在的 常用位置匹配有 (?=p)和(?!p)用来匹配一个位置，该位置后的字符要满足或不满足p模式 ^ , $分别表示字符串的开始和结束，如果有m修饰，则分别代表行首和行尾 \\b表示单词边界。它是\\w和\\W之间的位置，也包括\\w和^之间,\\w和$之间的位置。类似还有\\B 括号括号的作用主要有以下两种 分组12var reg1 = /^(\\d|[a-z])$/ var reg2 = /(ab)+/ 捕获分组使用了括号的内容会被捕获并保存下来，用于反向引用。我们可以在正则或api中使用他们。如果不想捕获，可使用非捕获分组，如/(?:\\d+)/ 正则中使用1var reg = /&lt;(\\w+)&gt; (.+) &lt;\\/\\1&gt;/ // 用于匹配html标签 其中的\\1表示第一个括号的内容，以此类推 API中使用如replace函数12\"2017-11-22\".replace( /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/,\"$1/$2/$3\") //$1-$99表示反向引用// \"2017/11/22\" tips 如果引用了不存在的分组，正则不会报错，而是匹配反向引用的字符本身。 \\10表示第10个分组 嵌套的括号以左括号出现的顺序为准 修饰符 g : global。正则默认只会找到第一个匹配，加上g可找到所有匹配 i : ignoreCase忽略字母大小写 m : multiline 仅改变^和$的含义，使二者变成行开头和行结尾。默认情况下它们代表字符串的开始和结束 匹配原理一般正则引擎有两种实现，一个(NFA)以正则表达式本身为主导，一个(DFA)以待匹配文本为主导。JavaScript的正则表达式引擎是传统型NFA的，在匹配时可能会产生回溯。1/.*\\d/.test(\"a1bc\"); 现有以上正则，以正则为基准，来匹配字符串，有如下过程。开始时由于是贪婪匹配会匹配整个文本，到了结束位置发现还是匹配不了于是尝试回溯。最终经过三次回溯匹配成功。这也提醒了我们，在写正则时可以具体些，让正则引擎尽早知道要回溯。例如trim的polyfill12345var str = ' 12 345 ';str.replace(/^\\s*(.*?)\\s*$/,\"$1\");//更优的写法str.replace(/^\\s+|\\s+$/g,\"\"); API常用API附加在String.prototype和RegExp.prototype上 RegExp.prototype包含exec 和test。具体用法看MDN就行了,这里不再介绍。需要注意，正则有修饰符g时，起始位置是从正则对象的lastIndex属性开始。连续使用时要小心。1234var regex = /(ab)+/g;regex.test(\"aab\"); //true regex.lastIndex == 3regex.test(\"aaab\"); //false 所以这里是falseregex.test(\"aaab\"); //true 又从0开始 String.prototypesearch用法类似RegExp.prototype.test，返回的是index。 match返回值类似RegExp.prototype.exec，区别在于全局匹配时会返回所有匹配字符串的数组。 split字符串分割用，它还有如下特点 接受第二个参数限制返回数组的长度 myString.split(/(,)/) 返回结果能包含, replace最常用且最为强大的API，纯函数无污染，RegExp.prototype.exec能做的它都能做，并且全局匹配时自动进行，不用再手动调用。可以直接使用$1等反向引用，也接受函数作为参数。具体用法 参考 JS正则表达式完整教程 正则表达式教程——语法篇 正则表达式教程——实践篇 正则工具","tags":[{"name":"javascript","slug":"javascript","permalink":"http://realwate.com/tags/javascript/"}]},{"title":"一对多sql查询","date":"2017-11-19T12:53:29.000Z","path":"一对多sql查询优化/","text":"N+1问题以User和Blog两个实体为例，关系为一对多，一个用户拥有多篇博客，现有需求要将所有用户及相关的博客一起展示出来，我们需要分别查询Blog和User表，有以下方式。 执行单条sql语句去获取user的记录(1条sql) 1select * from user; 对每一个用户，加载出他们的blog(有N个用户就需要N条sql) 1select * from blog where userId = ?; 显然sql的数目是随着用户数量的增长而增加的，最终可能会导致成千上万的sql语句执行，这就是N+1问题。 懒加载懒加载就是在用到数据实体的时候，才会调sql查询数据库。如果使用了MyBatis可以配置fetchType=&quot;lazy&quot;。 12&lt;collection property=\"blogs\" javaType=\"ArrayList\" column=\"blog_id\" fetchType=\"lazy\"ofType=\"Blog\" select=\"selectBlogsByuser\"/&gt; hibernate也可以设置lazy=true实现同样的效果。当然，懒加载只是解决了特定情境下的性能问题，我们如果在加载完所有user后立刻迭代访问对应的Blog，还是会调用所有的延迟加载，瓶颈依然存在。 表连接实际上我们可以通过表连接直接用一条sql查询出关联的数据，再根据定义的规则，将结果映射成JavaBean即可。在mybatis中可使用如下结果映射配置。select配置使用join连接User表和Blog表。12345678&lt;resultMap id=\"blogResult\" type=\"User\"&gt; &lt;id property=\"id\" column=\"blog_id\" /&gt; &lt;result property=\"name\" column=\"name\"/&gt; &lt;collection property=\"blogs\" ofType=\"Blog\"&gt; &lt;id property=\"id\" column=\"blog_id\"/&gt; &lt;!-- ... --&gt; &lt;/collection&gt; &lt;/resultMap&gt; hibernate中也可以设置outer-join=true 另一种写法以上提到的都是ORM框架自身提供的解决方案。如果我们现有的项目中并没有使用hibernate或mybatis等框架，而是自己轻度封装的ORM,又该如何处理呢。一般来说，基本的ORM都会提供一个基础的BaseDao来查询单个实体，对应到数据库的一张表。因此我们可以使用如下代码。12345678910111213141516171819202122232425262728BaseDAO dao = new BaseDAO();/* 查出全部user */List&lt;User&gt; users = dao.getAllVOs(User.class);/* 拼接userId */String queryString = mergeString(users);/* 查出users相关的Blogs */List&lt;Blog&gt; blogs = dao.queryByCondition(Blog.class, \"user_id in\" + queryString);Iterator itr = blogs.iterator();Map&lt;String, List&lt;Blog&gt;&gt; map = new HashMap&lt;String, List&lt;Blog&gt;&gt;();/* userId作索引 建立map */while (itr.hasNext()) &#123; Blog blog = (Blog) itr.next(); List&lt;Blog&gt; userBlogs = null; if (map.containsKey(blog.getUserId())) &#123; userBlogs = map.get(users.getUserId()); &#125; else &#123; userBlogs = new ArrayList&lt;Blog&gt;(); map.put(blog.getUserId(), userBlogs); &#125; userBlogs.add(blog);&#125;/* 设置blogs */for (User user : users) &#123; user.setBlogs(map.get(user.getId()));&#125; 虽然框架本身中没有提供懒加载或者表连接结果映射，我们也是可以通过两条sql查询出所有一对多关系的结果。再建立索引Map将多方的VO设置到一方。当然这种拼接sql语句如果in后接的条件太多，可以把in后的条件录入临时表，给临时表加索引，用表连接或者子查询代替。 总结总的思路都是尽量减少sql查询的次数，避免在循环中使用select带来的性能开销。","tags":[{"name":"用友","slug":"用友","permalink":"http://realwate.com/tags/用友/"},{"name":"JAVA","slug":"JAVA","permalink":"http://realwate.com/tags/JAVA/"}]},{"title":"JAVA动态代理实现机制","date":"2017-11-18T12:53:29.000Z","path":"JAVA动态代理实现机制/","text":"动态代理Java JDK中的到动态代理使用一般类似如下形式(部分省略) 1234567891011121314// 实现一个InvocationHandlerpublic class MyInvocationHandler implements InvocationHandler &#123; private Object target; MyInvocationHandler(Object target) &#123; super(); this.target = target; //保存要代理的对象 &#125; public Object invoke(Object oInvocationHandler, Method method, Object[] args) throws Throwable &#123; //...在这里实现代理类的行为... return method.invoke(target, args); &#125;&#125; 123456789public static void main(String[] args) &#123; UserService userService = new UserServiceImpl(); // 指定要代理的对象 InvocationHandler invocationHandler = new MyInvocationHandler(userService); // 调用JDK API UserService userServiceProxy = (UserService)Proxy .newProxyInstance(userService.getClass().getClassLoader(), userService.getClass().getInterfaces(), invocationHandler); &#125; 其中最重要的当然就是Proxy.newProxyInstance这个方法， Proxy.newProxyInstance分析JDK源码，我们来看一下 Proxy.newProxyInstance究竟做了什么。首先该方法有三个参数ClassLoader loader代表用来加载代理类的ClassLoader,Class&lt;?&gt;[] interfaces规定了代理类所必须实现的接口,InvocationHandler h指定调用代理类方法时的行为。该方法的部分源码如下 12345678910public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h) throws IllegalArgumentException &#123; //得到代理类 Class&lt;?&gt; cl = getProxyClass0(loader, interfaces); // 得到形参为InvocationHandler的构造函数 final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); // 构造实例并返回 return cons.newInstance(new Object[] &#123;h&#125; );&#125; 再来看下getProxyClass0做了什么 12345678910111213141516171819202122 private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; /** 1.优先从缓存中获取 Class对象 **/ Map&lt;List&lt;String&gt;, Object&gt; cache = loaderToCache.get(loader); Object value = cache.get(key); if (value instanceof Reference) &#123; proxyClass = (Class&lt;?&gt;) ((Reference) value).get(); &#125; if (proxyClass != null) &#123; // proxy class already generated: return it return proxyClass; &#125; /** 2.指定代理类的名字为 包名 + \"proxy\" + num **/ String proxyName = proxyPkg + proxyClassNamePrefix + num; /** 3.生成二进制字节码 **/ byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces); /** 4.加载类 最后返回proxyClass **/ proxyClass = defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);&#125; ProxyGenerator.generateProxyClass会按照字节码规范拼接字节码，使用java io操作写入类的信息，这些信息包括构造函数、给定接口的实现方法等。部分源码如下 123456789101112 /* 添加方法 */ addProxyMethod(hashCodeMethod, Object.class); addProxyMethod(equalsMethod, Object.class); addProxyMethod(toStringMethod, Object.class); /* 实现接口 */for (int i = 0; i &lt; this.interfaces.length; ++i) &#123; localObject1 = this.interfaces[i].getMethods(); for (int k = 0; k &lt; localObject1.length; ++k) &#123; addProxyMethod(localObject1[k], this.interfaces[i]); &#125;&#125; 简单来说，Proxy.newProxyInstance内部就是按照Java字节码规范生成了一个类并加载出来，这个类实现了我们指定的接口，拥有一个形参为InvocationHandler类型的构造函数，类的每个方法都会调用InvocationHandler.invoke,这样我们便可以通过InvocationHandler来定制该类的行为。 Mybatis使用Mybatis时，我们不需要自己写dao层的类，而是交给MyBatis动态生成，本质上使用的也是动态代理。所有的Mapper实现最后都会调用到MapperProxy，这个类实现了InvocationHandler接口。 12345public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //根据调用的Method信息 找到对应配置文件 从而生成sql final MapperMethod mapperMethod = cachedMapperMethod(method); return mapperMethod.execute(sqlSession, args); &#125; 总结Proxy.newProxyInstance的根本作用其实是动态生成一个类，而类的行为由我们提供的InvocationHandler定义。我们可以在InvocationHandler内实现代理,又或者作为一个dispatcher负责派发行为。","tags":[{"name":"用友","slug":"用友","permalink":"http://realwate.com/tags/用友/"},{"name":"JAVA","slug":"JAVA","permalink":"http://realwate.com/tags/JAVA/"}]},{"title":"谈谈arguments","date":"2017-11-10T09:42:03.000Z","path":"谈谈arguments/","text":"本文谈谈js中的arguments以及它相关的一些属性，在正常模式和严格模式下的表现出来的异同点及原因。 基础知识严格模式总的来说，严格模式就是对javascript的使用方式做了一些限制，消除javascript语法的一些不合理之处，减少一些怪异行为，同时使javascript更利于优化，运行的更加安全，高效。具体的规则可查看MDN阮一峰 内联优化内联优化通常就是在调用函数的地方“内联地”展开函数，将函数调用替换为函数实体。这样能减去函数调用的开销，但是这也可能导致代码体积膨胀，所以一般适合函数体不太长的小函数。 尾调用优化尾调用尾调用就是指某个函数的最后一步是调用另一个函数123function foo() &#123; return bar(); // 尾调用&#125; 调用堆栈函数在调用时会生成调用堆栈12345678910function foo() &#123; bar();&#125;function start() &#123; foo();&#125;function bar() &#123; debugger;&#125;start(); 以上代码会生成如下堆栈 我们可以看到，一般情况下，函数被调用时都会生成堆栈保留现场信息，以便函数返回时恢复现场，如果函数调用层次太多就会栈溢出。而尾调用由于是函数的最后一步操作，如果最后调用的函数不再依赖当前调用栈，那么就不需要保留外层函数的调用栈，直接用内层函数的调用栈，取代外层函数的调用栈就可以了，减少了不必要的内存开销。这种方式称为尾调用优化。因为尾调用优化发生时，函数的调用栈会改写，所以如果使用了依赖于调用栈的API会妨碍尾调用优化。另外，如果函数尾调用自己，就形成了尾递归，尾递归一般都会被优化成循环，因此不会出现栈溢出。在ES6中，严格模式下，会开启尾调用优化。 argumentsarguments对象是所有(非箭头)函数中都可用的局部变量。你可以使用arguments对象在函数中引用函数的参数。箭头函数中可以用 rest 参数代替。 追踪实参12345678910111213141516171819202122!function () &#123; \"use strict\"; function foo(a) &#123; console.log(arguments); arguments[0] = \"f\"; console.log(a) // 不变化 仍为q console.log(arguments); &#125; foo('q');&#125;()!function () &#123; function foo(a) &#123; console.log(arguments); arguments[0] = \"f\"; console.log(a) // 同步变化为f console.log(arguments); &#125; foo('q');&#125;() 结果如下 以上代码可知，正常模式下，arguments对象中的值会跟踪传进来的实参，即两者会同步变化。而严格模式两者是独立的。另外在es6中，当正常模式下的函数包含剩余参数、默认参数或解构赋值时，arguments对象中的值不再跟踪参数的值，具体可查看MDN例子。 function.arguments被标准废弃的属性，但是现在浏览器基本都保留了。function.arguments属性的值是最近一次该函数调用时传入的实参，如果函数不在执行期间，该属性的值是 null。与arguments相比，它能访问到外层函数的实际参数。123456789!function()&#123; function bar()&#123; console.log(foo.arguments) //能访问到外层foo的实参 &#125; function foo(a)&#123; return bar(); &#125; foo('q');&#125;() 在严格模式下不能访问 function.arguments ，因为通过function.arguments可能会访问外层函数栈的arguments，无法实现尾调用优化。 arguments.callee早期版本的 javascript不允许使用命名函数表达式, 所以添加了arguments.callee，指向当前执行的函数，用来实现递归，它的作用也仅此而已了。123[1,2,3,4,5].map(function (n) &#123; return !(n &gt; 1) ? 1 : arguments.callee(n - 1) * n; // 用来实现递归&#125;); this问题通过arguments.callee调用时，内部的this会指向外层的arguments123456789var i = 0;function foo() &#123; console.log(this); if (i++ == 0) &#123; arguments.callee(); //this为arguments &#125;&#125;foo(\"arg\"); 优化问题 严格模式下不能访问 arguments.callee ，因为arguments.callee 指向当前调用的函数，依赖了对非内联函数的引用，因而解析器不能将这类函数当做内联函数处理了,无法实现内联优化。 在今天arguments.callee已经有了更好的替代品，它自身又十分不利于优化，因此我们应该避免使用 arguments.callee.caller具体点说则是 Function.caller,虽然Function.caller是一个非标准的属性，但是现在的浏览器基本都实现了这个属性。fun.caller是最后一个调用fun的函数，而且fun.arguments包含调用fun时用的形参。如果一个函数f是在全局作用域内被调用的,则f.caller为null,相反,如果一个函数是在另外一个函数作用域内被调用的,则f.caller指向调用它的那个函数.如果函数不在执行期间，该属性的值是 null。通过Function.caller,能自由的访问函数堆栈。123456789101112function f() &#123; g()&#125;function g() &#123; h()&#125;function h() &#123; console.log(h.caller + '###' + h.caller.caller + '###' + h.caller.caller.caller)&#125;f()// function g()&#123;h()&#125;###function f()&#123;g()&#125;###null 显然这也不利于尾调用优化，所以不能在严格模式使用。 arguments.caller因为潜在的不安全性，被标准移除，主流的浏览器都未实现。 参考ECMAScript 6 入门MDN","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"},{"name":"javascript","slug":"javascript","permalink":"http://realwate.com/tags/javascript/"}]},{"title":"js中的排序","date":"2017-11-09T12:53:29.000Z","path":"js中的排序/","text":"起因js中排序的方法一般使用Array.prototype.sort，有次代码中需要用到，想当然的写出了如下代码。12var arr = [\"DC501\",\"B B\",\"ABC ABC\",\"A A\",\"DC106\",\"DX089\",\"DX088\",\"DX029\",\"DX074\",\"DX069\",\"DX081\",]arr.sort(function(a,b)&#123; return a &gt; b &#125;) 结果如下 显然是结果不对的，仔细查看了MDN和相关规范，特此记录。 Array.prototype.sort在MDN上，我们能得到如下信息。 参数可接受一个compareFunction，用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的诸个字符的Unicode位点进行排序。 返回值返回排序后的数组。原数组已经被排序后的数组代替。 如果没有指明 compareFunction ，那么参数会被转化为字符串类型，按照字典顺序比较。 如果指明了 compareFunction ，那么数组会按照调用该函数的返回值排序。即 a 和 b 是两个将要被比较的元素： 如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前； 如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为 如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。 compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。 重点 默认根据字典顺序排序。 sort 排序不一定是稳定的，依赖于浏览器实现 compareFunction 的返回结果应该有三种 小于 0， 等于 0，大于 0同时在规范中找到如下比较算法。 If x and y are both undefined, return +0. If x is undefined, return 1. If y is undefined, return -1. If comparefn is not undefined, then Let v be ? ToNumber(? Call(comparefn, undefined, « x, y »)). If v is NaN, return +0. Return v. Let xString be ? ToString(x). Let yString be ? ToString(y). Let xSmaller be the result of performing Abstract Relational Comparison xString &lt; yString. If xSmaller is true, return -1. Let ySmaller be the result of performing Abstract Relational Comparison yString &lt; xString. If ySmaller is true, return 1. Return +0. 根据以上信息，很明显我的代码返回的是boolean类型，调用compareFunction后会做ToNumber操作，也就是true返回1，false返回0。所以造成了以上结果。 undefined排序根据规范描述，undefined 属性值总是比任何其他值大，所以 undefined 属性值总是排在结果的末尾，另外undefined的判断是在调用comparefn之前，所以我们提供的comparefn是不会接收到undefined参数的。 String.prototype.localeComparelocaleCompare() 方法返回一个数字来指示一个参考字符串是否在排序顺序前面或之后或与给定字符串相同。 用法 referenceStr.localeCompare(compareString[, locales[, options]]) 参数localeslocales 参数必须是一个 BCP 47 语言标记的字符串，或者是一个包括多个语言标记的数组。如果 locales参数未提供或者是 undefined，便会使用运行时默认的 locale。关于语种标记可以参考阮老师的这篇博客 简单的来说，国际定义的描述一门语言的规则是下面这样的 language-extlang-script-region-variant-extension-privateuse 分别代表 语言文字种类-扩展语言文字种类-变体-使用区域-方言-扩展-私有 例如： zh-CN 表示用在中国大陆区域的中文。包括各种大方言、小方言、繁体、简体等等都可以被匹配到 zh-Hans 表示简体中文。适用区域范围是全宇宙用中文简体的地方，内容包括各种用简体的方言等 zh-Hant 表示繁体中文 zh-Hans-CN 表示在中国使用的简体中文 optionsoptions代表一些配置，具体可查看MDN 返回值 当 referenceStr 在 compareString 前面时返回 -1 当 referenceStr 在 compareString 后面时返回 1 相同位置时返回 0注意： 不应依赖于 -1 或 1 这样特定的返回值。不同浏览器之间（以及不同浏览器版本之间） 返回的正负数的值可能各有不同 拼音排序使用localeCompare即可12345678910function localeSort()&#123; var a = \"博,比,啊,吃,世,杀,中,长,超\"; a = a.split(\",\"); a.sort(function(a,b) &#123; return a.localeCompare(b,\"zh-Hans\"); &#125;); console.log(a);&#125;localeSort();// 结果[\"啊\", \"比\", \"博\", \"超\", \"吃\", \"杀\", \"世\", \"长\", \"中\"]","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"},{"name":"javascript","slug":"javascript","permalink":"http://realwate.com/tags/javascript/"}]},{"title":"移动端布局","date":"2017-11-05T06:40:58.000Z","path":"移动端布局/","text":"移动端的布局不同于PC端，因为我们要在各种条件的设备上使得同一个页面呈现出最佳的展示效果。现在业界也提供了多种思路来实现这一点，本文将分析移动端常用的布局及适配方案。理解本文所需的基础知识在此 问题其实所有的移动端布局主要都是为了解决以下两个问题。 不同屏幕尺寸的适配 屏幕像素密度的差异，有retina、retina HD这些高清屏幕存在其中主要要解决的问题是第一点，第二点往往是因为为我们要实现真正1px的线，充分利用高清屏幕的每个物理像素。 解决方案固定宽度1&lt;meta name=\"viewport\" content=\"width=640,user-scalable=no\" /&gt; 我们只需要设置宽度为一个固定值，该值等于设计稿的宽度(这里为640)，然后我们按照传统的方式去还原设计稿就行了，浏览器在显示时，会自动的缩放layout viewport到ideal viewport，使得页面恰好在一屏展示，并且使用user-scalable=no禁止用户缩放。荔枝FM使用的就是这种方式，我们可以在它的页面中找到如下代码(部分省略)123456789if (/Android (\\d+\\.\\d+)/.test(navigator.userAgent)) &#123; var version = parseFloat(RegExp.$1); if (version &gt; 2.3) &#123; var phoneScale = parseInt(window.screen.width) / 640; document.write('&lt;meta name=\"viewport\" content=\"width=640, minimum-scale = ' + phoneScale + ', maximum-scale = ' + phoneScale + ', target-densitydpi=device-dpi\"&gt;'); &#125; &#125; else &#123; document.write('&lt;meta name=\"viewport\" content=\"width=640, user-scalable=no, target-densitydpi=device-dpi\"&gt;'); &#125; 这段代码非常简单。它会判断手机的类型，如果是非安卓，直接设置width=640，由浏览器自动缩放到ideal viewport。对于安卓，考虑到某些机型不会自动缩放，因此需要手动计算出一个phoneScale = parseInt(window.screen.width) / 640;。(target-densitydpi=device-dpi的作用是使css像素与物理像素一一对应，现已被废弃)这种方式的本质其实就是等比缩放，虽然简单但也存在问题。640的布局放到大屏上，所有的元素都会很大甚至可能失真，不方便控制。而如果在小于640的设备上会出现像素丢失。 rem首先1rem就是根元素font-size的大小，开发时我们可以取1rem = 与设计稿尺寸相关的长度，例如取设计稿的1/10为1rem，所有需要适配的元素都选用rem做单位。最后到设备上显示时根据不同的设备条件，动态修改html的font-size为设备宽度的1/10，这样就能自动的根据设备宽度实现等比缩放。我们看看网易新闻的做法。 首先因为使用了rem这个单位，我们不在依赖meta的缩放，直接将layout viewport设为ideal viewport 当我们以iphone6去浏览时，1rem = 50px iphone6 plus,1rem = 55.2px 两台iphone的设备宽度分别为375、414(CSS像素)，计算出55.2 / 414 = 50 / 375 = 1 / 7.5 。因此网易新闻使用的1rem实际上等于设计稿的1/7.5。 对于要适配的元素单位使用rem 在页面中能找到如下设置font-size的js代码(部分省略)。1234567891011121314151617181920212223242526var uAgent = window.navigator.userAgent;var isIOS = uAgent.match(/iphone/i);function resizeRoot() &#123; var wWidth = window.innerWidth, wDpr, wFsize; var wHeight = window.innerHeight; if (window.devicePixelRatio) &#123; wDpr = window.devicePixelRatio; &#125; else &#123; wDpr = isIOS ? wWidth &gt; 818 ? 3 : wWidth &gt; 480 ? 2 : 1 : 1; &#125; if (isIOS) &#123; wWidth = screen.width; wHeight = screen.height; &#125; if (wWidth &gt; wHeight) &#123; //没有处理横屏 wWidth = wHeight; &#125; wFsize = wWidth &gt; 1080 ? 144 : wWidth / 7.5; //最大144px wFsize = wFsize &gt; 32 ? wFsize : 32; //最小32px // document.getElementsByTagName('html')[0].dataset.dpr = wDpr; document.getElementsByTagName('html')[0].style.fontSize = wFsize + 'px';&#125;resizeRoot(); 我们可以看到这种方式相比meta标签的缩放显得更加灵活。我们可以控制缩放的范围(32px - 144px)，也可以根据实际决定元素是否需要缩放，如果是使用rem，否使用px等单位。缺点当然也有，就是没有处理dpr大于1的情况(代码中有，但不知为何又注释掉了)。当然，个人认为是否要处理dpr要看实际的需求了，因为dpr &gt; 1的唯一坏处就是不能使用一个物理像素的单位了，同样1px，在高dpr下因为对应dpr个物理像素就会粗一下，如下两图所示 dpr=3 dpr=1 升级版rem这里就直接介绍手淘的做法了，具体可前往w3cplus 基本思路 根据dpr的值动态修改viewport的scale, scale = 1/dpr ，本质上是取消了 px 作为密度无关像素的含义，使得1css像素对应1物理像素。这样就能在retina等高密度屏幕上实现1px的线 。 同样是用rem做单位,取 1rem = 设计稿尺寸的 1/10在设备上显示时，动态计算1rem = document.documentElement.clientWidth / 10。document.documentElement.clientWidth 实际上就是经过缩放的layout viewport的宽度,它等于真实的物理像素的数量。 以iphone6为例，1rem = 375px * 2 / 10 = 75px。具体代码如下：12345678910111213141516171819var dpr, rem, scale;var docEl = document.documentElement;var fontEl = document.createElement('style');var metaEl = document.querySelector('meta[name=\"viewport\"]');dpr = window.devicePixelRatio || 1;rem = docEl.clientWidth * dpr / 10; // 1rem = 缩放后的layout viewport / 10scale = 1 / dpr;// 设置viewport，进行缩放，达到高清效果metaEl.setAttribute('content', 'width=' + dpr * docEl.clientWidth + ',initial-scale=' + scale + ',maximum-scale=' + scale + ', minimum-scale=' + scale + ',user-scalable=no');// 设置data-dpr属性，留作的css hack之用docEl.setAttribute('data-dpr', dpr);// 动态写入样式docEl.firstElementChild.appendChild(fontEl);fontEl.innerHTML = 'html&#123;font-size:' + rem + 'px!important;&#125;'; 关于字体一般字体不会使用rem，因为字体的大小和字体宽度，并不成线性关系。可以通过媒体查询修改body字体的大小来覆盖html元素的设置，同时所有子元素字体大小用em。123456789101112@media screen and (min-width: 320px) &#123; body &#123;font-size: 16px&#125;&#125;@media screen and (min-width: 481px) and (max-width:640px) &#123; body &#123;font-size: 18px&#125;&#125;@media screen and (min-width: 641px) &#123; body &#123;font-size: 20px&#125;&#125;p &#123;font-size: 1.2em&#125;p a &#123;font-size: 1.2em&#125; 还有方案吗技术的发展是不断向前的，可能几年前还流行的技术在今天已经无人问津，曾经很难解决的问题今天已经得到标准原生支持了。在今天，手淘又更新了他们的flexible方案，改用原生支持的vh，vw来代替rem，使用PostCSS插件帮我们做px到vh/vw之间的转换以及画出1px的线。具体不再阐述，可查看; 参考移动端适配方案(上)移动端适配方案(下)多屏适配方案MobileWeb 适配总结知乎rem布局","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"},{"name":"css","slug":"css","permalink":"http://realwate.com/tags/css/"}]},{"title":"css像素与viewport","date":"2017-11-02T13:17:56.000Z","path":"css像素与viewport/","text":"本篇为理解移动端布局时查找总结的一些基础知识，因相关概念很多，网上也能搜到，这里只介绍一些重点的内容。 基本概念物理像素(physical pixel)物理像素是显示屏的最小物理单位。物理像素是没有实际的物理尺寸的，是一个抽象概念 设备独立像素(device independent pixel)设备独立像素也称为密度无关像素，可以理解为一种逻辑像素，它能代表一个或多个物理像素 设备像素比(device pixel ratio)DPR = 物理像素数 / 逻辑像素数意义是表示一颗逻辑像素有多少颗物理像素构成 在线计算 屏幕像素密度(pixels per inch)表示每英寸有多少像素。手机的ppi = 对角线的像素数量 / 手机尺寸可通过google 查询 dip的意义css像素就是一种密度无关像素，通过window.devicePixelRatio可以知道一个css像素代表多少个物理像素。类似的还有安卓上的dp，ios上的pt。使用dip的根本意义是：使我们的应用在不同屏幕密度下的物理显示大小基本一致。如果没有该功能，则UI 元素（例如 按钮）在低密度屏幕上看起来较大，在高密度屏幕上看起来较小。摘自安卓开发文档 viewportPC在pc上，viewport基本可以认为是浏览器显示区域的大小。我们可以用window.innerWidth/Height 或者 document.documentElement.clientWidth 来获取视窗的大小,唯一的区别是前者包含了滚动条。而到了移动端，受限于屏幕尺寸大小的限制，viewport产生了不同的意义，演化出以下三种viewport。 视觉视窗(visual viewport)visual viewport就是当前显示给用户内容的窗口，大小由屏幕区域的 CSS 像素决定。visual viewport的大小和位置都不是固定的。当滑动屏幕，会改变visual viewport的位置。而缩放时，屏幕像素css像素变多，visual viewport随之变大，反之亦然。因为缩放的本质就是改变一个css像素可以容纳多少设备像素的能力 缩放 放大 visual viewport大小可以用window.innerWidth/Height获得。 布局视窗layoutviewportlayout viewport就是网页的全部内容。通过visual viewport所看到的就是layout viewport上的部分或全部内容，layout viewport其实等同于PC端上的viewport。html元素设置宽度为100%就是相对layout viewport,与设备宽度无关。iOS, Android基本都将这个视口分辨率设置为 980px，pc上的网页在手机上呈现时(未设置viewport)，一般浏览器都会默认缩放layout viewport，使visual viewport等于layout viewport，网页恰好在一屏幕展示，只不过元素看上去很小，要通过放大改变visual viewport才能看清。layout viewport大小可以用document.documentElement.clientWidth 获得。 理想视口(ideal viewport)在没有进行缩放的情况下，visual viewport宽度等于以css像素度量的设备宽度，在不同的设备中，这是一个常量，此时若设置layout viewport宽度等于该常量，就成为ideal viewport。它是对设备来说最理想的布局视口尺寸，用户进入页面的时候不需要缩放。我们可以通过以下方式设置meta标签使layout viewport成为ideal viewport12&lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; 说明 width=device-width 会使得 layout viewport = 设备宽度(CSS像素)，此时layout viewport等于ideal viewport，layout viewport刚好能在一屏展示， 因而visual viewport = layout viewport initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0 用于控制缩放，缩放比例相对的就是ideal viewport 当布局视口在width与inital-scale产生分歧时会选择它们中使得layout viewport比较大的那一个 例子重点说明meta对viewport设置起的作用。有以下html及样式12345678910&lt;!-- CSS --&gt;&lt;style&gt;.bg&#123; background: forestgreen; height: 100px;&#125;&lt;/style&gt; &lt;!-- html --&gt;&lt;div class=\"bg\"&gt;&lt;/div&gt; 以iphone6为例，iphone6的dpr为2，意味着一个css像素会用两个物理像素表示 一、 浏览器默认会缩小layout viewport在一屏展示。未设置meta标签，此时visual viewport等于layout viewport。可以看到layout viewport默认为980px 二、设置meta为1&lt;meta name=\"viewport\" content=\"width=device-width\"&gt; layout viewport等于ideal viewport 三、设置meta为1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=0.5\"&gt; width与init-scale冲突，缩放0.5倍，layout viewport变为750px，此时一个css像素用一个物理像素表示。 四、1&lt;meta name=\"viewport\" content=\"width=320\"&gt; 固定宽度为320px，浏览器会默认放大layout viewport让它在一屏展示，我们可以看到上图的高度成比例被放大了。 五、1&lt;meta name=\"viewport\" content=\"width=320,user-scalable=no\" /&gt; 在四的基础上添加user-scalable=no，禁止用户缩放，依赖浏览器的默认缩放行为，在小于320px的设备上自动放大到一屏，在大于320px的设备缩小到一屏。这样我们只需要按照320px(或任意宽度)来布局，页面就能自动适配不同尺寸。当然这种方式有一定不足，具体在下篇博客分析。 iphone系列的像素细节 iphone plus系列渲染是采用的是3倍dpr，但是最终的物理设备上像素却不够三倍,因此会做一个downsampling的过程，以一定的算法，把23个渲染的像素填充到20个物理像素中 总结 移动端的viewport与pc端的viewport含义不一样 三种viewport都是以CSS像素度量的，放大会让一个CSS像素对应更多的物理像素(缩小反之)，用户通过手指缩放就是改变visual viewport的尺寸(layout viewpor不变) 在设置width = device-width时，layout viewport = ideal viewport 。因此这也意味着ideal viewport等于以css像素度量的设备宽度 init-scale缩放比例是相对于ideal-viewport，而它改变的是layout viewport，与用户手动缩放是不一样的 参考翻译文章博客园viewport","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"},{"name":"css","slug":"css","permalink":"http://realwate.com/tags/css/"}]},{"title":"元素位置大小相关属性","date":"2017-11-02T12:16:14.000Z","path":"元素位置大小相关属性/","text":"浏览器中我们经常需要获取某个元素的位置大小相关的信息，这些都可以由DOMAPI来获取，我把相关的DOM属性分为几类来解释。 准备约定1234doc = document.documentElementbody = document.bodycotent-width = window.getComputedStyle(el).widthcss-width = 在box-sizing:content-box下设置的css宽度 文中提到的属性基本都是成对存在，因此只解释第一个，另一个类推即可。 测试浏览器大部分属性经过了测试，浏览器分别为chrome 60.0，firefox 55.0。 content-width与css-widthcotent-width一般是等于css-width的。但是如果出现了垂直滚动条，它的宽度会算在css-width上。此时在chrome下， content-width = css-width - 滚动条宽，而firefox不变。 相对自身的属性clientWidth/clientHeightclientWidth 属性表示元素的内部宽度。该属性包括内边距，但不包括垂直滚动条（如果有）、边框和外边距。clientWidth = css-width + 两侧padding - 垂直滚动条宽度(chrome/firefox下测试无误) scrollWidth/scrollHeight在有滚动条的情况下，等于滚动内容的长度。没有垂直滚动条时等于clientWidth（测试的时候发现line-height设的过小时会导致两者并不相等，猜测是行内元素的布局原因）。同时在设定了四个padding的情况下，chrome会将最右边的padding忽略，firefox会忽略右边以及下方的padding，chrome下的渲染结果如下图所示。 clientTop/clientLeft元素顶部边框的宽度 offsetWidth/offsetHeight一个典型的 offsetWidth = border + 水平padding + 竖直滚动条（如果存在的话）+ css-width经测试发现，chrome以及firefox都不会处理垂直滚动条，因为滚动条的宽度实际上是css-width的一部分了。所以 offsetWidth = border + padding + css-width 注意：以上所有属性都是只读属性，并且得到的结果都会四舍五入为一个整数。同时，在js中读取以上属性可能触发forced reflow，带来性能问题。 scrollTop/scrollLeft描述滚动条移动的距离。一个元素的 scrollTop = 元素 content-box 最高高度距离 - 元素可见高度的顶部当一个元素的容器没有产生垂直方向的滚动条,那它的 scrollTop 的值默认为0。我们可以修改该值来改变滚动的位置,设置的值最终会落在[0,最大滚动距离] 相对其它元素的属性offsetLeft/offsetTop元素相对于offsetParent节点的左边界偏移的像素值，即元素的border-box左边到offsetParent的padding-box的距离 offsetParent从当前元素逐步向上一层级寻找，直到遇见定位元素(position不等于static) 或 table 或 table cell 就返回该元素 ，如果都没有返回body。特殊的，有 body的offsetParent是null 元素的 style.display 设置为 none 或 自身有fixed定位时，offsetParent 返回 null getBoundingClientRect返回一个对象，描述了元素的大小及其相对于视口的位置。在chrome及firefox下都返回8个值，有以下关系1234right = left + widthbottom = top + height// width,height都是bordr-box的长度// x,y等同于 left,top ，但是有兼容性问题 特殊及常用window.getComputedStylewindow.getComputedStyle方法返回当前元素在应用了CSS后的所有CSS属性值。对于大多数属性，它是计算值computed value，但对于一些旧属性,比如width, height, padding，它是应用值used value。 名词解释 computed value: 浏览器不进行布局(layout)所能得到的最具体的值，用于CSS继承 used value： 布局后的值，会将百分比转化为像素 用法window.getComputedStyle(element, [pseudoElt])第二个参数指定一个要匹配的伪元素的字符串，如getComputedStyle(el, &#39;::after&#39;)。必须对普通元素省略（或null）。可参考MDN 获取网页的可视区域12window.innerWidth/innerheight //(包含滚动条)doc.clientWidth/clientHeight 获取整个网页的大小12345// 使用Math.max是为了兼容性 Math.max( body[\"scrollHeight\"], doc[\"scrollHeight\"], doc[\"offsetHeight\"], body[\"offsetHeight\"], doc[\"clientHeight\"] ); 是否有滚动条1elem.clientWidth &lt; elem.scrollWidth 是否滚动到底1el.scrollHeight - el.scrollTop === el.clientHeight 页面偏移量123// 使用||是为了兼容性var x = window.pageXOffset || doc.scrollLeft || body.scrollLeftvar y = window.pageYOffset || doc.scrollTop || body.scrollTop 元素偏移使用offsetParent12345678// 获取左偏移var left = element.offsetLeft;var parent = element.offsetParent;while(parent != null)&#123; left += parent.offsetLeft + parent.clientLeft; parent = parent.offsetParent;&#125;return left + 'px'; 但是在实践中发现对于使用了transform的元素获取到的偏移却是transform之前的，下面的方法可避免该问题。 使用getBoundingClientRectgetBoundingClientRect能获得距视窗的偏移， 再加上页面的滚动距离就能得到整个元素的偏移位置。如果要获取的是相对于html元素，则再减去html元素的border，jQuery的offset()实现方式就是这种。1234567// 简化版function offset()&#123; var box = element.getBoundingClientRect(); var top = box.top + window.pageYOffset //- doc.clientTop; var left = box.left + window.pageXOffset //- doc.clientLeft; return &#123; top: top, left: left &#125;;&#125; 一图概括一般元素 window相关 参考资料ElementHTMLElement流云诸葛","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"},{"name":"javascript","slug":"javascript","permalink":"http://realwate.com/tags/javascript/"}]},{"title":"attribute与property-JavaScript框架设计(3)","date":"2017-10-14T12:53:29.000Z","path":"attribute与property/","text":"attribute 与 property这两个词都是属性的意思，但是实际上并不相同，尤其是在DOM中。property是物体本身自带属性，attribute还可以做动词，表示赋予、把…归于等意思，所以作名词时可理解为人为赋予的可改变的属性 现有以下html1&lt;input id=\"kw\" name=\"wd\" class=\"s_ipt\" value=\"\" maxlength=\"255\" autocomplete=\"off\"&gt; 在dom中我们能拿到以下js对象表示该input节点其中，我们在html标记中使用的 诸如 id/name/class这些就属于attribute，而我们通过js对象拿到的各项属性就是property,两者之间并非毫无关联，而是存在着一些微妙的关系。 基本映射在创建DOM对象时，对于该节点的默认基本属性，如果存在attribute，会将它映射到对应dom对象的property中123&lt;input type=\"text\" value=\"ttt\" class=\"text\" custom=\"value\"&gt;&lt;!-- node.value 会被 value=\"ttt\"初始化 --&gt;&lt;!-- custome是自定义属性 不会映射到property --&gt; 一般来说property与attribute名称一致，但是对于一些关键字或保留字如class，就需要使用$0.className来获取。当然映射只会发生在节点的默认基本属性中，我们自定义的atrtibute，如custom则不会映射。 所有的attribute，我们都可使用setAttribute,getAttribute，removeAttribute 这三个API来获取和修改。此外，html5对于自定义属性data-*，会存储到DOM对象的dataset中。 规范化因为attribute本质上就是HTML标签上的属性，所以它的值只能够是字符串。在映射到property后，会对字符形式的attribute做一些规范处理。12&lt;input type=\"checkbox\" checked=\"checked\"&gt; &lt;a href=\"#a\"&gt;a&lt;/a&gt; checked会转为boolean类型，href也会被拼接为完整的url 联动变化attribute与property之间实际上是存在着一些联动。大多数情况下，修改attribute的数据会同步到property上，而修改property不会影响attribute。当然也存在一些例外12$0.setAttribute(\"value\",\"ff\"); //$0.value未变化$0.className = \"cls\"; //$0.getAttribute('class') == 'cls' 另外，所有在html中定义的attribute还可以通过attributes或者getAttributeNode拿到更详细的信息。 总结现在对于property与attribute，我们可以得出以下结论 property是DOM对象自身就拥有的属性，而attribute是我们通过设置HTML标签而给之赋予的特性，只能为字符串 元素在创建时就有property，在初始化时会同步一些默认基本attribute到property中，并予以规范化。 attribute和property的同名属性/特性之间会产生一些特殊的数据联系，而这些联系会针对不同的属性/特性有不同的区别。另外，在jquery中，attr与prop这两个方法就是分别用来获取attribute与property的 参考链接","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"},{"name":"javascript","slug":"javascript","permalink":"http://realwate.com/tags/javascript/"}]},{"title":"js中的浮点数","date":"2017-10-12T12:53:29.000Z","path":"js中的浮点数/","text":"谈谈js中的Number类型 存储原理js中的Number类型内部使用双精度64位表示二进制浮点数，遵循IEEE754标准。也就是说，不论整数小数，内部都是统一使用浮点数方式存取。等同于JAVA中的double。二进制浮点数可表示为 N=(-1)^s * M * 2^e (-1)^s表示符号位 M表示有效数字，1&lt;= M &lt;2 (3) 指数e 在IEEE754标准中，64位的浮点数采用以下格式其中符号位1位，指数(E)11位，尾数(M)52位 同时对于M、E有以下几点规定： M可以写成1.xxxxxx的形式，在计算机内部保存M时，就默认这个数的第一位总是1，因此可以只保存后面的xxxxxx部分此时计算公式为 N=(-1)^s * 1.M * 2^E 存储时的E = e + 1023,我们计算时要取出e = E-1023。当E全为0时，e等于-1023，有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字 E全为1时，e=2047-1023=1024,如果有效数字M全为0，表示±无穷大（正负取决于符号位s），如果有效数字M不全为0，表示这个数不是一个数（NaN） 知道了Number类型的内部存储机制，我们就可以理解js在处理数值类型出现的一些问题。 表示范围js能安全有效表示的最大整数为(以下用二进制表示)1.111(52个1) * 2^52 = 1111(53个1) = 2^53 - 1这个值也就是Number.MAX_SAFE_INTEGER, 用十进制表示为 9,007,199,254,740,991能表示出的最大的数为1.111(52个1) * 2^(2^10) = 111(53个1)000(971个)也就是Number.MAX_VALUE。大于 Number.MAX_VALUE的值代表 Infinity。而介于Number.MAX_SAFE_INTEGER与Number.MAX_VALUE之间的值只能表示出971个，不能完整连续的表示。 精度问题将一个十进制数转换为计算机存储的格式需要以下三步 转换成二进制 用二进制科学计算法表示 表示成 IEEE 754 形式 第一步转换成二进制时，可能原本在十进制中能准确表示的小数部分在二进制中却是无限循环/不循环小数，精度丢失第三步，受限于存储空间，64位的浮点数表示的有效位只能为二进制的53位。在表示大数时出现精度不足的问题。 另外浮点数运算时也可能发生精度丢失的问题。原因也不止一种，如 0.2 + 0.4 == 0.6000000000000001二进制下的0.2为 &quot;0.001100110011001100110011001100110011001100110011001101..&quot;0.4为&quot;0.01100110011001100110011001100110011001100110011001101..&quot;两者都是无限循环小数，在有限的存储空间下已经丢失了一定的精度，两者相加误差累计，导致结果不等于0.6 又如12Number.MAX_VALUE + 1 === Number.MAX_VALUE // true// 1.111111...1111 * 2^1024 + 1.0 * 2^0 这个问题在知乎上已经得到了解答，总的来说也是因为52位二进制有效长度的限制，在把一个小数与另一个大数相加时，小数精度丢失被round为0。 总结首先要明确一点，在计算机中，没有整数和小数,只有定点数和浮点数，浮点数表示的不仅仅是小数，包括整数和小数。js中的Number本质上就是浮点数。因为Number的内部存储原理， 虽然它最大能表示到1.7976931348623157 x 10^308，但是能连续表示的最大整数只到9,007,199,254,740,991。同时由于十进制二进制转换带来的误差，以及存储容量的限制，浮点数运算可能会丢失精度，导致结果不正确。 参考链接阮一峰知乎问题jusjavac规范浮点数在线表示","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"},{"name":"javascript","slug":"javascript","permalink":"http://realwate.com/tags/javascript/"}]},{"title":"js模块系统之循环依赖处理","date":"2017-10-09T12:53:29.000Z","path":"js循环依赖/","text":"写这篇文章的起因是在用requireJS时，碰到了循环依赖的场景，遂好奇现在主要的模块系统AMD、CommonJS、ES6它们是如何处理循环依赖，以及模块加载时的一些差异。 AMD问题AMD规范一般在浏览器端实现，当发生循环依赖时，它能做的有限，为了避免无限循环阻塞，产生循环依赖的模块会加载失败，我们得到的是undefined。如以下代码，a依赖b，b又依赖a，执行a.js，在b.js中拿到的a为undefined1234567891011// a.jsdefine(['b'],function(b)&#123;console.log(b) return \"a.js\"&#125;)//b.jsdefine(['a'],function(a)&#123; console.log(a) //a为undefined return \"b.js\"&#125;) 解决方案如果b依赖的a不需要立刻使用，可以延迟a模块在真正需要时加载1234567891011121314151617// a.jsdefine(['b'],function(b)&#123; console.log(b) return \"a.js\"&#125;)//b.jsdefine(function()&#123; function printA()&#123; //假设在执行某个函数时才需要a require([\"a\"],function(a)&#123; console.log(a); &#125;); &#125; return &#123; printA &#125;&#125;) CommonJS基于CommonJS规范的模块系统有以下两个特点。 当我们第一次require(&#39;./a.js&#39;)时，会同步的执行a.js里面的代码，然后返回 module.exports的值 同一模块require只执行一次，下次再require时直接从缓存中读取在nodejs中，require部分源码如下：123456789101112var cachedModule = Module._cache[filename]; //优先从缓存读取 if (cachedModule) &#123; return cachedModule.exports; &#125; //没有则new再加入缓存 var module = new Module(filename, parent); Module._cache[filename] = module; //加载 module.load(filename); return module.exports; 现有如下产生循环依赖的代码 a -&gt; b -&gt; a12345678910111213141516171819// a.jsexports.start = \"start a.js\"var b = require('./b');console.log(b)exports.end = \"end a.js\"//b.jsexports.start = \"start b.js\"var a = require('./a');//这里的a只能拿到a.start而不能拿到a.endconsole.log(a)setTimeout(function()&#123; //只要等a模块加载完毕，这里的a就是完整的 console.log(\"a,b都加载完毕时\",a)&#125;,0)exports.end = \"end b.js\"// main.jsrequire(\"./a\") 执行main.js,结果如下1234567start in a.jsstart in b.js&#123; start: &apos;start a.js&apos; &#125;end in b.js&#123; start: &apos;start b.js&apos;, end: &apos;end b.js&apos; &#125;end in a.jsa,b都加载完毕时 &#123; start: &apos;start a.js&apos;, end: &apos;end a.js&apos; &#125; 整个过程如下： require(&#39;./a&#39;) // main.js 加载a require(&#39;./b&#39;) // a.js加载b require(&#39;./a&#39;) // b.js加载a，此时模块a已经在cache中(没有执行完)，直接返回a的 exports对象，这个时候的a只有一个属性就是start 执行完b.js返回到a.js继续，a中拿到的b是完整的。 最后当a、b模块都加载完毕，在b模块中的a也能拿到a.end属性。 CommonJS只解决了一半问题。在b.js中，加载完a后,如果我们需要访问a.end实际上是获取不到的，他只能拿到a.js在require(&#39;b&#39;)之前exports对象暴露的属性。必须要等到a,b两个都加载完成才能保证各自拿到的exports是完整的。 解决方案基于这种处理方式，我们可以集中把每个模块的导出部分放到前面，然后再导入其他模块。也就是先exports，在require12345// a.jsexports.start = &quot;start a.js&quot;exports.end = &quot;end a.js&quot; // 提到require之前var b = require(&apos;./b&apos;);console.log(b) 这样b.js中拿到的属性就会包含end了 ES6 Modules不同于以上的两种社区提出的方案，es6的模块机制是作为语言标准实现的，与CommonJS相比，有以下几点重大差异： 所有的 import和export语句都会在代码执行之前被解析出来。也就是在编译期确定输出变量 import的变量，都是动态引用被加载的模块 import 对于相同的模块只会执行一次代码，以后其他任何模块再次import时只会添加一个动态的符号引用指向该模块对应的符号 以下代码为例123456789101112131415161718// a.jsconsole.log('start in a.js')import &#123;bar&#125; from './b.js'console.log(bar);export default \"default\";export function func()&#123;&#125;export let name = 'Peter'export var year = 2017;console.log('end in a.js')// b.jsconsole.log('start in b.js')import * as a from './a.js'console.log(a)export let bar = 'bar'console.log('end in b.js') 在Chrome中(63.0.3235.0 canary)通过以下方式引入1&lt;script type=\"module\" src=\"./a.js\"&gt;&lt;/script&gt; 执行结果如图： 其中start in a.js在start in b.js下方是因为import语句会自动提升(hoist)。看上去好像不同于CommonJS,在b模块中的console.log打印出了a模块暴露的全部变量。我们在b.js中，import * as a from &#39;./a.js&#39;后添加断点，具体分析下: 这时代码执行情况如图 a变量能拿到的属性有func，year,name,default，这是因为这些变量在编译期就确定了。他们分别各自指向a模块export的同名变量。 但是为什么只有func属性有值呢?首先由于import/var/function都会在当前作用域提升，所以我们将a.js中的变量提升后再分析。123456function func()&#123;&#125;var year import &#123;bar&#125; from './b.js'/* ... */ 再import命令作用之前，符号func已经定义，用var声明的year初始化为undefined，由于name是用let声明，在未初始化前引用它会导致 ReferenceError，default跟let一样，因为 1234export default \"default\"//等同于const __default__ = \"default\";export &#123; __default__ as default &#125;; 所以基于es6 Module的模块在b中能拿到的a同样也是不完整的。接下来b.js执行完毕，返回a.js，a,b都加载完毕。这个时候b.js中的a变量就能访问到a模块暴露的全部接口。 可以发现，es6 Module其实类似CommonJS，对于a -&gt; b -&gt; a这种依赖情况，在b中能访问到的a都是有限的一部分，除非a中export的变量全部提升到import前面(例如全是函数声明)。 总结es6 Module与CommonJS最大的区别就是但是还是有一些好处 我们在b模块试图访问a中未初始化的let变量会直接抛ReferenceError。这有助于我们提前发现循环依赖的错误。 CommonJS模块输出的是一个值的拷贝，import是直接引用其他Module的暴露的变量，能保证永远获取到最新的值123456789101112var num = 1;// CommonJS中num的变化不会再反应到exports中，/// 仅仅只是拷贝一次值。exports.num = num;// es6 Module始终引用这个numexport &#123;num&#125;;//num变化setTimeout(function()&#123; num = 10; &#125;,1000) 参考链接阮老师循环依赖1循环依赖2循环依赖3exploringjs","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"},{"name":"javascript","slug":"javascript","permalink":"http://realwate.com/tags/javascript/"}]},{"title":"浏览器嗅探技术-JavaScript框架设计(2)","date":"2017-10-07T12:53:29.000Z","path":"浏览器嗅探技术/","text":"浏览器嗅探技术是处理浏览器兼容性的前线阵地。 浏览器判定浏览器的判定主要使用 navigator.userAgent ，但是实际上这个值是可以任意被浏览器厂商修改的，有些浏览器甚至会故意伪装成某个主流浏览器，因此获取到的值是不可靠的。现在除了在某些场合如数据统计等，已经不推荐使用该技术。 事件支持事件侦测的基本思路就是创建一个元素el,检测它是否有&#39;on&#39; + eventName属性，对于一些特殊的事件如input、change等要创建有对应该事件的元素。 同时注意，这种检测只对DOM0事件有效，无法检测 DOMContentLoaded等特殊事件。12345678910111213141516171819var isEventSupported = (function()&#123; var TAGNAMES = &#123; 'select':'input','change':'input', 'submit':'form','reset':'form', 'error':'img','load':'img','abort':'img' &#125; function isEventSupported(eventName) &#123; var el = document.createElement(TAGNAMES[eventName] || 'div'); eventName = 'on' + eventName; var isSupported = (eventName in el); if (!isSupported) &#123; el.setAttribute(eventName, 'return;'); isSupported = typeof el[eventName] == 'function'; &#125; el = null; return isSupported; &#125; return isEventSupported;&#125;)(); 样式支持样式的支持类似事件，也是先创建一个元素el,只不过检测的对象是el的style属性。1234567891011121314151617181920212223var supports = (function() &#123; var div = document.createElement('div'), vendors = 'Ms O Moz Webkit'.split(' '), len = vendors.length; return function(prop) &#123; if ( prop in div.style ) return true; prop = prop.replace(/^[a-z]/, function(val) &#123; return val.toUpperCase(); &#125;); while(len--) &#123; if ( vendors[len] + prop in div.style ) &#123; return true; &#125; &#125; return false; &#125;;&#125;)(); if ( supports('textShadow') ) &#123;&#125; CSS.suportsCSS.suports是一个比较新的API，因此存在一定兼容性问题。可以在CSS中使用，类似媒体查询12345@supports (display: flex) &#123; div &#123; display: flex; &#125;&#125; 也可以直接在js中使用12CSS.supports(\"display\", \"flex\");CSS.supports('(--foo: red)'); 总结浏览器的判定主要使用 navigator.userAgent ，除了某些场合已经不推荐使用 事件与样式的支持都可以通过创建一个元素然后检测他的 style对象及 onXXX 属性。 样式的支持还可以使用新的API CSS.supports","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"},{"name":"javascript","slug":"javascript","permalink":"http://realwate.com/tags/javascript/"}]},{"title":"javascript类型检测-JavaScript框架设计(1)","date":"2017-10-06T12:53:29.000Z","path":"javascript类型检测/","text":"js中存在两种数据类型，分别是 基本类型(primitive value) Boolean Null Undefined Number String Symbol (ECMAScript 6 新定义) 对象类型(Object) 通常来说，我们会使用 typeof运算符来检测基本类型，instanceof检测对象类型。但是因为一些历史的原因以及早期浏览器对标准实现的差异性，有时使用这两个运算符也会踩到坑。 1234567891. typeof null === 'object'2. typeof document.childNodes === 'function' //safari3. typeof /\\d/i === 'function' // Chrome 1-12 4. typeof alert === 'object' //IE6,7,85. var iframe = document.createElement(\"iframe\")document.body.append(iframe)var arr = window.frames[0].Array(3)arr instanceof Array //false 第1点，javaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是0。由于 null代表的是空指针(大多数平台下值为0x00)，因此，null的类型标签也成为了0，typeof null就错误的返回了&quot;object&quot;。第2,3,4点都是因为浏览器在实现上与规范不一致的情况。第5点，iframe中的Array不等于window下的Array，所以instanceof返回false。综上，我们会发现javascript自带的类型检测存在的一些缺陷，同时在实际开发中，我们有时需要比较准确并且详细的判断一个数据类型，现在主流框架及库内部都会配套的实现isXXX方法，我们来看下主要的实现。 isArray判断是否为数组类型。 基于javascript的鸭子类型思想，这种方法也是最不可靠的。 1234567funciton isArray(o)&#123; return o != null &amp;&amp; 'length' in o;&#125;funciton isArray(o)&#123; return o != null &amp;&amp; typeof o.sort === 'function'&#125; 判断原型链，这种方法在跨iframe比较时会出现问题 123456funciton isArray(o)&#123; return o instanceof Array;&#125;funciton isArray(o)&#123; return !!o &amp;&amp; o.constructor === Array;&#125; 最后一种是现在主流的实现，就是使用Object.prototype.toString(以下称为__toString)这个方法。根据规范描述，当调用该方法时，会执行以下步骤： If the this value is undefined, return “[object Undefined]”. If the this value is null, return “[object Null]”. Let O be the result of calling ToObject passing the this value as the argument. Let class be the value of the [[Class]] internal property of O. Return the String value that is the result of concatenating the three Strings “[object “, class, and “]”. 可以知道，在参数 !=null 时，__toString的返回值是由&quot;[object &quot; + class + &quot;]拼接而成，class的值等于参数的内部属性[[Class]]使用__toString，我们可以轻松的判断大部分浏览器内置类型了。123456funciton isArray(o)&#123; return __toString.call(o) === '[object Array]'&#125;function isRegExp (v) &#123; return _toString.call(v) === '[object RegExp]'&#125; isPlainObject判断是否为纯净的javascript对象，而不是DOM等复杂对象，一般用来判断类似{}、Object.create(null)这样的对象123function isPlainObject(o)&#123; return __toString.call(o) === '[object Object]'&#125; isNumeric判断是否为Number类型或者能转化为Number类型123function isNumeric(e) &#123; return !isNaN(parseFloat(e)) &amp;&amp; isFinite(e)&#125; isWindow判断是否为window对象1234function isWindow(o)&#123;var rwindow = /^\\[object (?:Window|DOMWindow|global)\\]$/ return rwindow.test(__toString.call(o))&#125; isNaN判断NaN这个标志,window上挂载的isNaN方法在判断字符串对象等非Number类型是也返回true，而有时我们需要判断真正的NaN123function isNaN(o)&#123; return o!=o;&#125; 总结对于原生的类型检测，我们使用Object.prototype.toString.call(o)可解决90%以上的类型检测，剩下的我们可以根据其特征、跨浏览器的差异性使用正则等方式。","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"},{"name":"javascript","slug":"javascript","permalink":"http://realwate.com/tags/javascript/"}]},{"title":"大数据量表格渲染","date":"2017-07-23T05:40:00.000Z","path":"大数据量表格渲染/","text":"在大数据量背景下，表格渲染的优化。 背景业务开发中需要对1000家单位或子公司执行对账操作，最后返回数据到前台渲染成一个1000*1000的表格，浏览器直接卡死，数十秒之后页面崩溃，惨不忍睹。即使使用setTimeout对返回的数据分块、异步渲染，在拉动滚动条时仍然有明显的卡顿。于是在网上寻找类似的大数据量下表格渲染的解决方案。 分页加载在后台提供了相应分页接口，并且UE及产品都接受这种分页的交互方式的话，可以直接对表格做分页处理，每次只请求部分数据。缺点就是可能交互不太好，数据显示不够直观，分页的数量取决于数据的数量级。 部分渲染这也是现在业界普遍使用的一种方式。操作系统中有一个概念叫做局部性原理。在装载程序只会装载开始的一部分指令，等到访问虚拟内存出现缺页中断时，再去加载另一部分。 我们图形界面显示也是一样的道理，即使你有上亿的数据量，渲染出来一张巨大的表格，但是我们人眼能直接接触感受到的只会是其中一部分。 基于这样的一个原理，我们可以尝试一开始只渲染部分数据，等到用户的滚动操作快要到达边界时，我们进行计算，然后再动态的加载这部分数据并渲染，因为每次只渲染很小一部分的数据量，CPU的处理速度非常快，我们根本不会感觉到差异。 有一个开源的库clusterize.js做的就是这种处理。 参考饿了么","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"},{"name":"性能优化","slug":"性能优化","permalink":"http://realwate.com/tags/性能优化/"}]},{"title":"Vue变化侦测机制","date":"2017-07-15T02:11:41.000Z","path":"Vue的变化侦测机制/","text":"关于Vue的变化侦测机制，上一篇讲的是不是很全，这里补上。 引言我们知道，Vue是通过属性的getter来收集依赖，一旦属性变化则触发Watcher的update，而这里面就涉及到了如何侦测数据变化的问题。针对多种更新数据的方式，我们必须确保在每一种情况下都能监测到数据的变化，从而正确的更新视图或者触发回调。让我们看看Vue是怎么做的。 Setter监听通过诸如 a = xxx 这样直接赋值的方式会触发属性的setter， 而这正是Vue最基本也是最通用的监听数据变化的方式。123456789101112131415161718192021222324252627 function defineReactive$$1 ( obj, key, val, customSetter) &#123; /* ... */ Object.defineProperty(obj, key, &#123; /* .... */ set: function reactiveSetter (newVal) &#123; var value = getter ? getter.call(obj) : val; if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; if (\"development\" !== 'production' &amp;&amp; customSetter) &#123; customSetter(); &#125; if (setter) &#123; setter.call(obj, newVal); &#125; else &#123; val = newVal; &#125; childOb = observe(newVal); dep.notify(); &#125; &#125;);&#125; 在源码中，我们可以看到，触发setter后，会调用observe()方法递归的重定义成响应式属性，同时更新本地闭包中的childOb引用，然后dep.notify，dep负责维护getter收集到的所有的依赖，notify会通知所有的Watcher触发更新，当然为了性能，Watcher是会放在一个队列中异步执行的。 数组处理通过setter看起来似乎能检测到所有数据的更新，但是在一些情况下，我们完全可能在不触发setter的情况下改变数据，比如数组的 push、pop、shift等方法。因此，Vue中对数组做了特殊处理。在调用observe时，会给每个属性定义唯一的Observer123456789101112131415Observer = function Observer (value) &#123; this.value = value; this.dep = new Dep(); this.vmCount = 0; def(value, '__ob__', this); if (Array.isArray(value)) &#123; var augment = hasProto ? protoAugment : copyAugment; augment(value, arrayMethods, arrayKeys); this.observeArray(value); &#125; else &#123; this.walk(value); &#125;&#125;; 其中，如果是数组类型，会做特殊处理1234var augment = hasProto ? protoAugment : copyAugment; augment(value, arrayMethods, arrayKeys); 这里的arrayMethods是通过Object.create方法构造的，它继承了Array.prototype中的方法，同时重写了 ‘push’ ‘pop’,等几个方法。其实这就是用JS原型继承的方式 实现了传统OOP语言 例如Java中 extends、override 的效果。 12345678910111213141516171819202122232425262728293031323334353637383940414243var arrayProto = Array.prototype;var arrayMethods = Object.create(arrayProto);[ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) &#123; // cache original method var original = arrayProto[method]; def(arrayMethods, method, function mutator () &#123; var arguments$1 = arguments; // avoid leaking arguments: // http://jsperf.com/closure-with-arguments var i = arguments.length; var args = new Array(i); while (i--) &#123; args[i] = arguments$1[i]; &#125; var result = original.apply(this, args); var ob = this.__ob__; var inserted; switch (method) &#123; case 'push': inserted = args; break case 'unshift': inserted = args; break case 'splice': inserted = args.slice(2); break &#125; if (inserted) &#123; ob.observeArray(inserted); &#125; // notify change ob.dep.notify(); return result &#125;);&#125;); 然后 hasProto会检测有没有proto这个属性，有的话直接将数组的proto指向arrayMethods，相当于间接继承了Array.prototype，形成如下关系： 这样原有的数组方法不会丢失，同时实现了自己定义的push、pop等方法，用于侦测变化。 如果没有的话 也会调用Object.defineproperty在数组对象上重定义这几个方法。12345678910function protoAugment (target, src) &#123; target.__proto__ = src;&#125;function copyAugment (target, src, keys) &#123; for (var i = 0, l = keys.length; i &lt; l; i++) &#123; var key = keys[i]; def(target, key, src[key]); &#125;&#125; 其他不能解决的方式在另一些情况下，受限于Javascript这门语言的限制，还是会出现无法检测变化的问题。例如假设我们初始定义123data = &#123; name: \"xxx\" &#125;; 然后在某个时候，我们添加age属性 data.age = 18; 以期望视图中跟age绑定的部分更新。当然，结果是令人失望的，视图不会有任何变化。原因在Vue的文档上也提到了 受现代 JavaScript 的限制（以及废弃 Object.observe），Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的 同时也给出了解决方案 Vue 不允许在已经创建的实例上动态添加新的根级响应式属性(root-level reactive property)。然而它可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上：","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"},{"name":"Vue","slug":"Vue","permalink":"http://realwate.com/tags/Vue/"}]},{"title":"Vue数据绑定浅析","date":"2017-07-10T02:11:41.000Z","path":"Vue数据绑定浅析/","text":"Vue提供了基于依赖收集的数据绑定机制,只要数据改变就能立即通知该数据的依赖对象. 下面是我基于一个demo，跟踪部分源码总结出的Vue数据绑定的主要原理。 开始1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;vue-component&lt;/title&gt; &lt;script src=\"vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt; &lt;h1&gt;&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123;fullName&#125;&#125;&lt;/h2&gt; &lt;button @click=\"changeName\"&gt;ChangeName&lt;/button&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el:\"#app\", data()&#123; return &#123; name:\"Peter\" &#125; &#125;, methods:&#123; changeName()&#123; this.name = \"Jack\"; &#125; &#125;, computed:&#123; fullName()&#123; return \"fullName \" + this.name; &#125; &#125;, watch:&#123; name()&#123; console.log(\"name Change\") &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 接下来将会一步一步跟踪代码的执行,看Vue在初始化以及数据发生变动的过程中做了哪些事情，其中展示的源码不一定完全，可能会部分精简。首先，当我们将配置项传给Vue时,它内部会调用Vue.prototype._init方法,执行初始化.123456789101112Vue.prototype._init = function (options) &#123; var vm = this; /* ... */ vm._self = vm; initLifecycle(vm); initEvents(vm); callHook(vm, 'beforeCreate'); initState(vm); callHook(vm, 'created'); initRender(vm); &#125;; 这里我们主要关注的是数据的处理,以及对数据的依赖关系是如何建立的,所以主要看initState和initRender两个方法 initState(vm)12345678function initState (vm) &#123; vm._watchers = []; initProps(vm); initMethods(vm); initData(vm); initComputed(vm); initWatch(vm);&#125; 主要关注initData(vm);,initComputed(vm);,initWatch(vm);他们分别会处理我们传进来的 data/computed/watch 选项 initData(vm); 123456789function initData (vm) &#123; var data = vm.$options.data; /* ... */ /* ...这里会将 vm._data[key] 的访问代理到vm上 */ /* ... */ observe(data); data.__ob__ &amp;&amp; data.__ob__.vmCount++;&#125; 主要执行的就是observe(data) 123456789101112131415161718function observe (value) &#123; if (!isObject(value)) &#123; return &#125; var ob; if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__; &#125; else if ( observerState.shouldConvert &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) &#123; ob = new Observer(value); &#125; return ob&#125; observe函数用于递归的将传进来的数据定义成响应式的,直到最后传进来的value不是Object类型. 123456789101112131415var Observer = function Observer (value) &#123; this.value = value; this.dep = new Dep(); this.vmCount = 0; def(value, '__ob__', this); //__ob__标记 if (Array.isArray(value)) &#123; //特殊处理数组的 push等方法 var augment = hasProto ? protoAugment : copyAugment; augment(value, arrayMethods, arrayKeys); this.observeArray(value); &#125; else &#123; this.walk(value); &#125;&#125;; Observer构造函数中会添加__ob___属性来标记Observer,表示该对象已经重定义过.如果value是数组类型会特殊处理.然后执行walk方法,针对对象的每一个属性,调用defineReactive$$1. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function defineReactive$$1 ( obj, key, val, customSetter) &#123; var dep = new Dep(); var property = Object.getOwnPropertyDescriptor(obj, key); if (property &amp;&amp; property.configurable === false) &#123; return &#125; // cater for pre-defined getter/setters var getter = property &amp;&amp; property.get; var setter = property &amp;&amp; property.set; var childOb = observe(val); Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; var value = getter ? getter.call(obj) : val; if (Dep.target) &#123; dep.depend(); if (childOb) &#123; childOb.dep.depend(); &#125; if (Array.isArray(value)) &#123; dependArray(value); &#125; &#125; return value &#125;, set: function reactiveSetter (newVal) &#123; var value = getter ? getter.call(obj) : val; if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; if (setter) &#123; setter.call(obj, newVal); &#125; else &#123; val = newVal; &#125; childOb = observe(newVal); dep.notify(); &#125; &#125;);&#125; defineReactive$$1函数是Vue最终用Object.defineProperty重定义属性的地方，这里的代码就是Vue实现依赖收集的原理。此处代码的精妙之处就是在一个闭包中维护了dep和childOb这两个变量.他们都会通过属性的getter来收集依赖,具体的收集过程会在下面初始化Watcher介绍.这里可以认为是收集依赖前的准备工作 一般情况下，当通过setter改变数据的时候,dep通知所有的Watcher执行异步更新.针对数组类型,可以通过push/pop等方法来间接改变数据结构,这种方式会绕过setter,Vue中也对这种情况作了特殊处理.它重写了push等方法,一旦push,会调用该对象Observer上的相关方法,也就是:12var ob = this.__ob__; //这里的ob其实就是上文中的childObob.dep.notify(); 实现通知Watcher的目的. initComputed(vm);这是Vue对计算属性的处理.123456789101112131415161718192021function initComputed (vm) &#123;for (var key in computed) &#123; var userDef = computed[key]; if (typeof userDef === 'function') &#123; computedSharedDefinition.get = makeComputedGetter(userDef, vm); computedSharedDefinition.set = noop; &#125; else &#123; computedSharedDefinition.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, vm) : bind$1(userDef.get, vm) : noop; computedSharedDefinition.set = userDef.set ? bind$1(userDef.set, vm) : noop; &#125; Object.defineProperty(vm, key, computedSharedDefinition);&#125; &#125; 最终会将计算属性通过Object.defineProperty()定义到vm上，而该属性的getter为 computedSharedDefinition.get = makeComputedGetter(userDef, vm); 1234567891011121314 function makeComputedGetter (getter, owner) &#123; var watcher = new Watcher(owner, getter, noop, &#123; lazy: true &#125;); return function computedGetter () &#123; if (watcher.dirty) &#123; watcher.evaluate(); &#125; if (Dep.target) &#123; watcher.depend(); &#125; return watcher.value &#125;&#125; 计算属性的getter访问其就涉及到Watcher了,它的内部其实就是new Watcher,并调用Watcher相关的方法.在前文defineReactive函数中,我们已经知道,可以通过data的getter记录具体的依赖项.这些依赖项其实就是一个个Watcher.12345678910//在属性的getter中有如下代码if (Dep.target) &#123; dep.depend(); if (childOb) &#123; childOb.dep.depend(); &#125; if (Array.isArray(value)) &#123; dependArray(value); &#125; &#125; 12345678910111213141516Dep.prototype.depend = function depend () &#123; if (Dep.target) &#123; Dep.target.addDep(this); &#125;&#125;; Watcher.prototype.addDep = function addDep (dep) &#123; var id = dep.id; if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id); this.newDeps.push(dep); if (!this.depIds.has(id)) &#123; dep.addSub(this); //最终将Watcher添加到dep中 &#125; &#125; &#125;; 每个Watcher对象都拥有getter方法,在这个方法中会访问数据,从而触发data的getter.在此处,我们的getter就是计算属性中的fullName.123fullName()&#123; return \"fullName \" + this.name; &#125; 在fullName中会访问name选项，触发name的getter，使得这个Watcher被添加到dep中，完成依赖收集。同时,在调用getter之前,会将当前的Watcher置为Dep.target,让data的getter能访问到Watcher。 12345678910111213141516171819202122232425262728293031var Watcher = function Watcher ( vm, expOrFn, cb, options) &#123; //确定Watcher的getter 每次数据变化时调用这个getterif (typeof expOrFn === 'function') &#123; this.getter = expOrFn; &#125; else &#123; this.getter = parsePath(expOrFn); if (!this.getter) &#123; this.getter = function () &#123;&#125;; &#125; &#125; /* ... */ this.value = this.lazy ? undefined : this.get();&#125;;Watcher.prototype.get = function get () &#123; pushTarget(this); //将当前Watcher置为全局 var value = this.getter.call(this.vm, this.vm); //触发Watcher的getter //这个getter是由我们传递进来的参数 expOrFn 决定的 popTarget(); return value&#125;; 计算属性对应的Watcher是懒加载的,他会在第一次访问计算属性的时候(也就是解析到模板中的)才建立依赖关系，并计算出值。 initWatch(vm);initWatch最终是调用vm.$watch方法。1234567891011121314151617 Vue.prototype.$watch = function ( expOrFn, cb, options ) &#123; var vm = this; options = options || &#123;&#125;; options.user = true; var watcher = new Watcher(vm, expOrFn, cb, options); if (options.immediate) &#123; cb.call(vm, watcher.value); &#125; return function unwatchFn () &#123; watcher.teardown(); &#125; &#125;;&#125; 在我们的例子中，expOrFn 为 &quot;name&quot;,cb为我们提供的回调函数123name()&#123; console.log(\"name Change\") &#125; 在new Watcher中会判断expOrFn是否为函数，然后将&quot;name&quot;转化为getter 123456789101112131415 this.getter = parsePath(expOrFn);function parsePath (path) &#123; if (bailRE.test(path)) &#123; return &#125; else &#123; var segments = path.split('.'); return function (obj) &#123; for (var i = 0; i &lt; segments.length; i++) &#123; if (!obj) &#123; return &#125; obj = obj[segments[i]]; &#125; return obj &#125; &#125;&#125; 这个getter用于访问对象给定路径中的属性。 与计算属性不同的时,Vue在处理watch选项时没有懒加载，会立即调用this.get()，将这个watcher置为Dep.target，然后调用getter，getter会从对象结构的外层到内层依次访问对象的属性，触发get操作，将Watcher作为依赖，保存到经历过的每一个属性的dep内 initRender(vm);把模板编译成JavaScript，渲染并插入到真实DOM，这个过程中会触发依赖收集。12345678910111213141516171819202122232425262728function initRender (vm) &#123; /* .... */ if (vm.$options.el) &#123; vm.$mount(vm.$options.el); &#125;&#125;Vue$3.prototype.$mount = function ( el, hydrating) &#123; if (!options.render) &#123; /* ... */ if (template) &#123; var ref = compileToFunctions(template, &#123; warn: warn, shouldDecodeNewlines: shouldDecodeNewlines, delimiters: options.delimiters &#125;, this); var render = ref.render; var staticRenderFns = ref.staticRenderFns; options.render = render; options.staticRenderFns = staticRenderFns; &#125; &#125; &#125; return mount.call(this, el, hydrating)&#125;; 如果initRender执行时发现我们没有给出render函数，它就会直接调用compileToFunctions 将模版编译成render函数，然后再调用mount(); 1234567891011121314151617181920212223function compileToFunctions ( template, options, vm) &#123; var key = options &amp;&amp; options.delimiters ? String(options.delimiters) + template : template; if (cache[key]) &#123; return cache[key] &#125; var res = &#123;&#125;; var compiled = compile$$1(template, options); res.render = makeFunction(compiled.render); var l = compiled.staticRenderFns.length; res.staticRenderFns = new Array(l); for (var i = 0; i &lt; l; i++) &#123; res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i]); &#125; return (cache[key] = res)&#125; compileToFunctions函数中，会优先从缓存中读取之前的结果，如果没有才执行编译。 1234567891011121314151617181920212223Vue.prototype._mount Vue.prototype._mount = function ( el, hydrating ) &#123; var vm = this; vm.$el = el; /* ... */ callHook(vm, 'beforeMount'); //vm._watcher是专门更新视图的Watcher //下面的function就是该watcher的getter vm._watcher = new Watcher(vm, function () &#123; vm._update(vm._render(), hydrating); &#125;, noop); hydrating = false; if (vm.$vnode == null) &#123; vm._isMounted = true; callHook(vm, 'mounted'); &#125; return vm &#125; 可以看到，在编译完成后执行的mount操作最终会new Watcher(),而这个Watcher比较特殊，它是用于更新视图的Watcher，所以被挂载到 vm._watcher。 关于Watcher构造函数的内容前面也贴出来了，它内部会将这个Watcher置为全局Dep.target,然后调用我们传递的expOrFun作为getter，也就是 vm._update(vm._render(), hydrating); 来更新视图 123456789101112Vue.prototype._render = function () &#123; var vm = this; var ref = vm.$options; var render = ref.render; var staticRenderFns = ref.staticRenderFns; /***/ //调用render函数生成VNode 此处的render会访问data 触发getter收集依赖 vnode = render.call(vm._renderProxy, vm.$createElement); /****/ return vnode &#125;; vm._render()会调用我们之前编译好的render函数最后生成VNode节点挂载到vm._vnode，也就是虚拟DOM。在执行render的时候，如果有数据绑定会触发data的getter操作进行收集依赖，将当前的Watcher添加到闭包中定义的 dep的subs中。 123456789101112131415161718192021Vue.prototype._update = function (vnode, hydrating) &#123; var vm = this; if (vm._isMounted) &#123; callHook(vm, 'beforeUpdate'); &#125; var prevEl = vm.$el; var prevActiveInstance = activeInstance; activeInstance = vm; var prevVnode = vm._vnode; vm._vnode = vnode; if (!prevVnode) &#123; vm.$el = vm.__patch__(vm.$el, vnode, hydrating); &#125; else &#123; vm.$el = vm.__patch__(prevVnode, vnode); &#125; /* ... */ if (vm._isMounted) &#123; callHook(vm, 'updated'); &#125;&#125;; Vue.prototype._update就是首次渲染或者数据变化更新视图调用的方法。它内部真正调用的方法是 vm.__patch__()。它内部的代码逻辑其实很简单，在首次渲染时，会直接将VNode转化为真实的DOM节点，插入到DOM中，触发浏览器渲染，mount操作结束，调用callHook(vm, ‘mounted’);而如果是更新操作，则会通过diff算法计算出两个VNode节点的差异，然后做增量更新。 总结至此，Vue的初始化工作结束，我们可以在浏览器上看到渲染后的视图。整个过程用官方文档的这张图形容再恰当不过. 总结一下，其实整个过程中主要是做了两件事情 对data处理最关键的部分就是在一个函数闭包中用Object.defineProperty重定义对象属性。dep用来保存通过getter收集依赖(Watcher). 在defineReactive中还会递归的调用observe直到该属性不是Object类型. 建立依赖关系前面的准备工作已经完毕,接下来就可以建立并保存依赖关系了.所有依赖于data的部分都会通过Watcher来封装.总的来说,在Watcher创建时，会调用的this.get，里面会执行根据expOrFn解析出来的getter。在这个getter中，我们或渲染页面，或获取某个数据的值。总之，会调用相关data的getter，来建立数据的双向绑定。例如 :在我们的例子中，watch选项如下12345watch:&#123; name()&#123; console.log(\"name Change\") &#125; &#125; Vue会构造一个Watcher,”name”转化为如下getter,并立即调用，访问name属性触发name属性的getter123function()&#123; return vm[\"name\"];&#125; 计算属性的处理基本类似,它会将属性定义在vm上,访问该属性时才调用Watcher的getter,计算出value并返回1234567891011121314 function makeComputedGetter (getter, owner) &#123; var watcher = new Watcher(owner, getter, noop, &#123; lazy: true //不会在new Watcher时计算 &#125;); return function computedGetter () &#123; if (watcher.dirty) &#123; watcher.evaluate(); //真正计算并建立依赖关系 &#125; if (Dep.target) &#123; watcher.depend(); &#125; return watcher.value &#125;&#125; 而另外一个特殊的Watcher就是我们用于渲染视图的vm._watcher.通过源码我们发现,在一个组件中,模板依赖的每一个data属性都会绑定同一个Watcher,这个Watcher做的事就是更新组件的视图.也就是说,在Vue2.0版本的数据绑定策略其实不是很细粒度的那种. 这意味着如果一个组件内部的某个属性值发生了变化,我们其实没有记录这个属性具体绑定到组件的哪个部分,而是更新整个组件,内部再通过diff算法算出真正变化的部分. 这也是Vue算法在 时间和空间消耗之间 取得的一种平衡,我们只会通过依赖收集机制知道数据变化影响到的是哪个组件,而所谓的增量更新再通过virtualDOM diff算法实现.","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"},{"name":"Vue","slug":"Vue","permalink":"http://realwate.com/tags/Vue/"}]},{"title":"前端框架发展史","date":"2017-07-05T02:11:41.000Z","path":"前端框架发展史/","text":"本文翻译自原文地址,没有全文翻译,只摘取了部分. 引言过去七年以来，前端框架这个生态系统(ecosystem)发展迅速。我们已经学习到很多关于构建并维护一个大型应用的知识。我们看到了许多新的解决方案出现，其中一些改变了我们构建Web应用的方式，而另一些被我们遗弃(discarded)，因为它们没有产生效果。 在这个过程中，我们看见了许多充满炒作(hype)和抵触的观点，这使得很难去选择一个框架。当您为长期维护此应用程序的组织挑选框架时，这种选择尤其困难。 在这篇文章中，我会讲述我们对于构建一个现代Web应用的理解是如何演变(evolution)的，并且给出一种思考如何选择技术的方法。 开始Backbone首先，让我们回到第一个出现的框架，它使得构建Web应用的感觉更像编程。Backbone.js在2010年10月首次发布，并且在2013年3月发布1.0版本。它是第一个被广泛使用的的JS库之一，介绍了将Model、View分离的思想。 Backbone的Model代表了数据和业务逻辑。他们提交change到View。当change事件触发时，View负责(responsible)将change应用到DOM中。Backbone没有模版的概念，而是将更新DOM的操作留给了开发者。 Angular.js当Backbone 1.0发版时，Angular.js也正式发布逐渐开始积累名气。不同于Backbone的专注于Model层，Angular.js希望使View层变得更简单。它介绍了动态编译模版到HTML的方法。允许使用指令(Directives)注入到HTML中。这样将Model和View绑定在一起，一旦Model变化，View会自动更新。 Angular.js发展迅速，因为将它添加到任何一个项目是很简单的一件事，而且门槛也非常低。同时因为Angular.js是谷歌开发,吸引了更多的开发者。 WebComponents与此同时，WebComponents规范(specification)使得开发者能够创建与上下文隔离(isolated)的可复用的小部件，并且部件之间的组合使用十分简单。 WebComponents规范包含4个独立的规范。 HTML模版 - 提供了HTML标记 自定义元素 - 提供了创建自定义元素的机制(mechanism) Shadow DOM - 将组件的内部从渲染它的上下文隔离出来 HTML Import - 使得加载WebComponents 到页面成为可能 Polymer谷歌的一个团队创建了一个polyfill库用于在所有的浏览器上实现WebComponents。这就是 Polymer，它在2013年11月开源。 Polymer是第一个通过组件的组合使得创建可交互(interactive )的的应用成为可能。早期的使用者受益于它的组合性(composability),但同时也发现了需要解决(addressed)的性能问题。 Ember.js与此同时，一个小的开发者团队受到了Ruby on Rails思想(ideology)的启发,想要去创建一个基于会议约定的(convention-based)、社区驱动的开源框架用于构建大型Web应用。他们在 SproutCore 2.0基础上进行开发，这是一个基于MVC架构的框架，在M、V、C之间有着清晰的分层。新框架就是Ember.js。 他们碰到的第一个挑战就是要找出大型Web应用之间通用的模式。Ember.js团队着眼于大型的Backbone应用,以找出共同点。他们确定需要呈现嵌套的视图，并且视图可能会发生切换。他们将URL作为Web应用结构中的重要角色。于是,结合了嵌套视图的想法和URL的重要性，他们创建了一个路由系统，作为入口点进入应用程序并控制初始视图呈现。Ember社区在Ember.js核心团队的领导下在2013年8月发布了1.0版本。它具有MVC的架构，强大(robust)的路由系统，组件由可编译的模版组成。 就像Angular.js和 Polymer 一样，Ember.js重度依赖于双向绑定去保持state与view的同步. React大约在2014年中期,一个新的库开始引起开发者的注意.Facebook为他们的平台创建了一个框架 ，随后命名为React发布。 正当所有其他的框架依赖于对象变化(object mutation)和属性绑定( property bindings)时，React提出了一种新的思想，它将一个组件看作一个pure function，组件的参数作为函数的参数。一旦参数的值发生变化，组件的render函数会被调用并且返回一个新的组件树。 React会将新返回的组件树与之前的虚拟DOM树的作比较，以确定如何更新真实的DOM。这种重新渲染所有内容并将结果与虚拟DOM进行比较的技术证明是非常有效的 此时，由于Angular.js的变化侦测机制(change detection mechanism)，开发者们开始遇到了性能问题。Ember社区正在学习解决 维护依赖双向绑定和观察者的大型应用 带来的挑战。 React实现了Polymer未能完成的功能。它展现了组件结构也是能实现高性能。React已经将Ember、Angular.js远远甩在身后。一些勇敢的Backbone开发者开始将React作为视图层添加到他们的应用中，以解决他们遇到的性能问题。 进步作为对React威胁的回应，Ember核心团队创建了一个方案去采纳React介绍的特性到Ember框架中。 他们认识到需要向后兼容性，并提供了升级的方案，允许现有应用程序升级到新版本 – 包含受React启发而开发的新渲染引擎。 在之后的过程中，Ember将社区迁移到基于CLI构建，并将基于组件的架构作为Ember应用程序开发的基础。 正当Ember从React中学习时，React社区也吸收了Ember推广的路由系统。如今，大型React应用都会使用到React Router。 Ember对如何构建现代Web应用程序最大的贡献之一是他们的领导力和普及使用命令行工具作为构建和部署Web应用程序的默认界面。那就是EmberCLI。它启发了React的create-react-app和AngularCLI。每个Web框架今天都提供了一个命令行工具来简化Web应用程序的开发。 大约在2015年中期，Angular.js核心团队得出结论，他们的框架正在走向一个死胡同。Google需要一个开发人员可以用来构建强大的应用程序的工具，而Angular.js不能成为这个工具。他们开始研究一个新的框架，这将是Angular.js的精神继承者。与Angular.js不同，Angular.js在谷歌很少的支持下变得流行起来，这个新框架完全由Google支持。Google投入了超过30位开发者，他们将新框架称为 Angular。 新框架的范围远远大于Angular.js。 Angular团队将新框架称为平台，因为他们计划提供专业开发人员构建Web应用程序所需的一切。像Ember和React一样，Angular使用基于组件的架构，但它是使TypeScript成为其默认编程语言的第一个框架。TypeScript提供类，模块和接口。它支持可选的静态类型检查，是来自Java和C＃的开发人员的完美语言。Visual Studio对TypeScript提供出色的Intellisense支持。 Angular是高度结构化和基于约定的，同时仍然提供了配置机制。它有一个强大的路由器。 在2017年5月，Polymer2.0改进了其绑定系统，减少了对重型polyfill的依赖，并与最新的JavaScript标准保持一致。新版本引入了一些突破性变化，并为用户升级到新版本提供了详细的指引。新的Polymer配备了一个命令行工具来帮助构建和部署Polymer项目。 截至2017年6月，所有顶级框架都将组件架构作为开发范式(development paradigm)。每个框架都提供路由作为将应用程序分解为逻辑块的一种手段.所有框架都可以使用像Redux这样的状态管理技术。 React，Ember和Angular都允许服务器端渲染(ssr),实现SEO和更快的首次启动时间。 自我总结通过这篇文章我们可以了解到前端框架是如何一步步发展壮大到今天的地步,这个过程中既有彼此竞争也有互相学习,最后演变成我们今天看到的繁荣的地步.诸如 路由系统/组件思想/构建CLI/状态管理等概念也是在发展的过程中逐步得到各家的认可采纳，然后才发扬光大,我们现在接触到的一些概念也是经过一段时间的发展沉淀而来,要想轻易的掌握还是没这么简单的,任重道远,还需努力。","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"},{"name":"翻译","slug":"翻译","permalink":"http://realwate.com/tags/翻译/"}]},{"title":"React渲染原理理解","date":"2017-06-20T02:11:41.000Z","path":"React渲染原理理解/","text":"在前端框架发展过程中，React的出现让我们眼前一亮，它给我们带来了一些崭新的理念。 揭示了一个组件就是一个函数，同时蕴含了一些FP的思想。 在MVVM的基础上，提出了大型应用的状态管理的解决方案 数据的渲染采用了virtualDOM和diff算法这一篇主要介绍的就是React的渲染处理，以及它这样做的原因。 Backbone的思考BackBone实现了数据与视图的分离，但是数据与视图之间的同步需要我们自己来维护。一旦数据变化，我们可以手动的调用render方法，而render方法封装了我们实现的DOM操作，一般是重新渲染整个innerHTML。缺点很明显，只要state改变一小部分，整个调用render方法时会触发大面积DOM更新，带来效率问题。 仔细思考，DOM更新带来的效率问题主要体现在两方面： DOM节点对象本身就是个重量级对象，规范要求可能要实现诸如HTMLElement、Node等接口，并且挂载了大量原型、属性，频繁的访问势必会带来性能开销。 DOM更新会使的浏览器重新渲染部分区域，因此带来的parse html -&gt; recalculate style -&gt; layout -&gt; render -&gt; paint等一系列渲染的过程也是极其耗时的。 很显然，Backbone效率问题的关键就是带来了不必要的DOM更新。设想一下，我只更新了一个字段的值，你整个页面就重新渲染一遍这显然是不合理的。我们需要一种算法去找到我们数据变化影响到的那一部分DOM，然后只更新这部分变化的DOM。 React的处理具体步骤如下： 用JS对象模拟DOM树，在React中，render函数本质上最后的返回结果是一个普通的javascript对象，用于描述一个DOM节点的结构。例如 type记录节点的类型，props描述节点的各类属性，如果type是function，则表示是一个组件，props.children包含所有子节点的描述对象。返回的这个对象可以表示一个组件的虚拟DOM树结构。它没有真实DOM节点那样庞大、复杂的属性，可以看作一个轻量级的DOM树。 当setState通知框架数据发生变化时，React并不知道哪部分数据发生了变化。首先调用对应该state组件的render方法返回一个全新的虚拟DOM节点对象，这个对象代表了一颗虚拟DOM树。注意，如果没有在当前组件及子组件中使用shouComponentUpdate,会从当前组件的根节点从头到尾构建一颗DOM树然后再使用diff算法对两个节点作比较，找出最小差异。 将找到差异部分更新到真实DOM中。 关于diff算法传统比较两颗树差异的算法 时间复杂度为O(n^3) (n为节点的数量),为了对算法优化，React做出了一些假设 两个相同组件产生类似的DOM结构，不同的组件产生不同的DOM结构。这意味着，在比较两颗不同类型的节点时，将直接全部重新构建成新的节点，而不再比较子树。理念就是：与其浪费时间去比较它们基本上不会等价的DOM结构，还不如完全创建一个新的组件加上去。 基于这个假设，我们在比较时只会比较同一级别的DOM节点，这样只需要对树进行一次BFS遍历，便能从上到下，完成整个虚拟DOM树的比较。 如果两个节点类型相同，则覆盖props。如果类型不同，则完全删除后再重建。这里就会出现一个性能问题，如果同一级别的节点仅仅只是掉换了位置，通过diff算法他们都将会销毁并重新创建，而实际上我们只需要移动节点就可以达到效果，此时可以提供一个key属性，用于标识结点。(实际上，在某些情况下即使带了 key，也可能带上了不必要的元素移动操作（对比最优算法) 正因为React对diff算法时间复杂度做了优化，因此最终算出来的DOM操作不一定是最优解。也就是可能比我们自己手动操作真实DOM要多几步。 参考ppt渲染过程diff算法知乎问题","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://realwate.com/tags/React/"}]},{"title":"es6class揭秘","date":"2017-06-08T12:53:29.000Z","path":"es6class揭秘/","text":"在es6中，新增了class关键字用于定义一个类，但是本质上并没有给javascript增加新的oop机制 ，因为javascript原型继承以及构造函数式声明使人感到晦涩难懂，添加class的目的就是为了掩盖它底层的机制，使得我们不用直接接触这些概念，相当于一个语法糖。 class语法在chrome中运行以下代码12345678910111213141516171819class Super&#123; constructor()&#123; this.name = \"Super\"; &#125; superSayHello()&#123; console.log(\"super hello\") &#125; &#125; class Sub extends Super&#123; constructor()&#123; super(); this.realName = \"Sub\"; &#125; subSayHello()&#123; console.log(\"sub hello\") &#125; &#125; var sub = new Sub(); 调试观察sub的值。 我们发现所有的方法都是定义在对象的prototype属性上,不难得出这几者的关系如下图所示 es5语法es6中的class与我们之前写的原型继承基本一致，同样的关系用es5来写的话123456789101112131415161718function Super()&#123; this.name= \"Super\";&#125;Super.prototype.superSayHello = function()&#123; console.log(\"super hello\")&#125;;function Sub()&#123; //借用父类构造函数 等价于es6中的super() Super.call(this); this.realName= \"Sub\";&#125;//以上只实现了数据的复制//使用Object.create() 而不是new Sub(); 避免调用两次Sub();Sub.prototype = Object.create(Super.prototype);Sub.prototype.constructor = Sub;var sub = new Sub(); 扩展因为javascript本质上是没有类这个概念，一切皆对象，为了模拟其它面向对象语言的特性(如JAVA)，出现了许多种间接实现继承的方法。以上es5的继承其实就是我们说的寄生式组合继承，也是javascript中最常用的继承模式。","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"},{"name":"javascript","slug":"javascript","permalink":"http://realwate.com/tags/javascript/"}]},{"title":"Thinking in React","date":"2017-06-04T02:15:57.000Z","path":"React/","text":"如何从零打造一个React App，摘自官方文档一步一步实现如下效果 将UI划分为组件层次结构进行划分的一个重要原则是单一职责原则，这意味着在理想状态下，每一个组件只做一件事。(在React中，一个组件的本质就是一个函数，多个组件之间的组合其实就是调用不同的函数)基于这个原则，对我们的UI划分组件。 FilterableProductTable (orange): 包含整个app SearchBar (blue): 接受用户的输入 ProductTable (green): 基于用于输入显示结果 ProductCategoryRow (turquoise): 显示类别 ProductRow (red): 显示内容 基于React构造一个静态的版本把mock数据传递给顶层组件。12345678910const PRODUCTS = [ &#123;category: 'Sporting Goods', price: '$49.99', stocked: true, name: 'Football'&#125;, &#123;category: 'Sporting Goods', price: '$9.99', stocked: true, name: 'Baseball'&#125;, &#123;category: 'Sporting Goods', price: '$29.99', stocked: false, name: 'Basketball'&#125;, &#123;category: 'Electronics', price: '$99.99', stocked: true, name: 'iPod Touch'&#125;, &#123;category: 'Electronics', price: '$399.99', stocked: false, name: 'iPhone 5'&#125;, &#123;category: 'Electronics', price: '$199.99', stocked: true, name: 'Nexus 7'&#125;];ReactDOM.render(&lt;App products=&#123;PRODUCTS&#125;/&gt; ,document.getElementById(\"root\")) 在组件内部用props把数据从父组件传递到子组件，不要使用state。state代表着那些经常变化的数据，是用来创建动态可交互的界面而不是静态的,一个界面其实就是渲染state后的结果(view = render(state))， 定义一个最小且完整的集合来表示组件的state思考组件中依赖于数据展现的部分，考虑它是否能作为state的一部分。 能由父组件传递过来，不需要 永远不会变化的数据，不需要 能基于state或props计算得到，不需要 state的位置React使用的是单向数据流，也可以称之为自顶向下的数据流，即数据只会从父组件传递到子组件，虽然这可能会使我们写出一些多余的代码，但它会使我们思考问题变得清晰明了，给后期的维护扩展带来方便。 根据上一步得到的state，找到所有依赖于state的组件。 找到所有这些组件的公共父组件，如果没有则创建一个container，这就是我们用来存储state的container component。 container component会通过props把state传递给下级的presentational component，这样整个app就由一颗组件树构成，并且数据只会从上级传递到下级。 解决反向的数据流由于React的单向数据流只能由父传递到子，如果子组件需要改变父组件的状态，它不能直接更改，而是应该调用父组件传递过来的一个接口(一个回调函数)，由该state所属的父组件去改变，子组件仅仅只是调用该接口而已。这样就不会破坏单向数据流模型。","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"}]},{"title":"base64揭秘","date":"2017-05-10T02:11:41.000Z","path":"base64揭秘/","text":"最近在做Excel导出功能，由于我们的架构后台有两层，要从集中式的Service后台根据业务生成Excel文件并传输到中间层服务器，再由中间层服务器返回http响应让浏览器处理文件下载。这个过程中要用base64处理二进制Excel文件内容后才能传输，因此简单了解了一下base64。 介绍base64定义了64个字符，即大小写字母、数字、＋和／，以及用作后缀等号＝,每个符号都对应着一个唯一的编码(这是base64规定的，不同于ASCII)。base64还提供了一种编码方式将任意一组字节转换为以上64个字符，具体的规则也很简单，就是将一串字节序列逐个取6位，对于后面不足6位的填充 \\x00,同时在末尾添加等同 \\x00个数 的=。 现在浏览器提供了btoa用于转成base64格式，以btoa(&#39;0&#39;)为例，我们来分析一下。 0的ASCII为48，二进制序列为 0011 0000 转成base64 001100 00 00 00 后面补了两个\\x00，所以最后需要添加两个= 最终结果为 001100(12对应M) 000000(0对应A) == 即 MA== 作用可以看到，base64的其实就是将字节序列按照给定规则转换成一串可见字符串。本质上是一种编码的转换。一些底层不支持二进制的协议需要传输二进制时可使用base64编码后再进行传输，还有一些协议有特殊的解析规则，如http头部的key-value，如果value中含有”:”会使得http解析程序错误，这也可以使用base64编码后再发送。","tags":[{"name":"用友","slug":"用友","permalink":"http://realwate.com/tags/用友/"}]},{"title":"浏览器调用本地程序","date":"2017-03-22T01:29:46.000Z","path":"浏览器调用本地程序/","text":"平时浏览一些网站，如下载电影，点击一个磁力链接就自动调用迅雷下载，或者是招聘网站点击联系我就能打开qq并且切换到添加好友界面，这样的效果是如何实现的呢？ 我们都知道，浏览器为了安全性是不允许js直接调用操作系统的接口，即没有访问操作系统的权限，只能通过浏览器给定的API间接调用，因此，如果想纯粹的使用一段js就打开操作系统上的一个二进制程序，这显然是不现实的。 当我们在浏览器地址栏输入一段url，如果浏览器不能解析，就会到操作系统注册表中查找支持该协议的程序，并将协议后的字符串作为参数传过去。所以我们只需要添加一项注册表就可以完成这个功能，称之为自定义协议 以下是我写的在浏览器根据参数调用windows操作系统上的程序，作用相当于在操作系统上直接windows+r,注册表如下 123456789101112131415Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\cmd]@=\"cmd.exe\"\"URL Protocol\"=\"\"[HKEY_CLASSES_ROOT\\cmd\\DefaultIcon]@=\"\\\"C:\\\\Windows\\\\System32\\\\cmd.exe\\\"\"[HKEY_CLASSES_ROOT\\cmd\\shell][HKEY_CLASSES_ROOT\\cmd\\shell\\open][HKEY_CLASSES_ROOT\\cmd\\shell\\open\\command]@=\"\\\"C:\\\\Windows\\\\System32\\\\cmd.exe\\\" \\\"%1\\\"\" 只要运行这段脚本就在本机注册了一个cmd的自定义协议，浏览器端直接这样就能调用了 1location.href = \"cmd:///c start xxx\" //xxx为要启动的程序名 为了更好的用户体验，可以使用隐藏的iframe来调用。","tags":[{"name":"用友","slug":"用友","permalink":"http://realwate.com/tags/用友/"}]},{"title":"unicode笔记","date":"2017-03-20T11:23:42.000Z","path":"unicode笔记/","text":"了解unicoe字符集与基于它的各种编码方式。 ASCII美国标准，用7位二进制表示。 ISO-8859-*扩展了ASCII，用8位表示。如 ISO-8859-1,包括了书写所有西方欧洲语言不可缺少的附加字符。 Unicode字符集概念每个字符都有唯一的Unicode code point表示，unicode字符集定义了几乎地球上所有字符对应的唯一编码。但是他只规定了字符与编码之间的映射，却没有给出具体的实现方案，因而出现了许多以unicode字符集为基础的编码方案。现在的unicode包含了17*65536个字符。 UCS-2使用两个字节固定长度表示，对应unicode字符集中前65536个字符，是unicode的早期实现。 BOM在UCS编码中有一个叫做”ZERO WIDTH NO-BREAK SPACE”的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符”ZERO WIDTH NO-BREAK SPACE”。 这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符”ZERO WIDTH NO-BREAK SPACE”又被称作BOM。 UTF-8相当于UCS的变种，因为UCS中英文字符只需要一个字节却占用了两字节的空间，因此出现了utf-8变长编码方案，本质上还是使用ucs编码的基础上再加工。兼容ASCII 无字节序1230xxxxxxx //单字节1110xxxx 10xxxxxx 10xxxxxx //两字节在utf-8标准下 feff 两字节编码为 EF BB BF0 utf-8中以单字节(8bit)位编码基础，不存在字节序问题(从11开始的那一端为第一个字节)，因此在windows上使用BOM标识为UTF-8编码(被很多人吐槽)。 UTF-16相当于UCS-2的升级版，在UCS-2中只能表示U+0000到U+FFFF的BMP(Basic Multilingual Plane ) Unicode编码范围，属于定长的Unicode实现， 而UTF-16是变长的，类似于UTF-8的实现，但是由于其字节长度的增加，所以BMP部分也做到了一一对应，但是其通过两个双字节的组合可以做到表示全部Unicode，表示范围从U+0000 (65536 )到 U+10FFFF (1114111 )。 人们将这 1114111 个码位划分成17个平面(plane), 每个平面包含 65536 个码位, 每个平面的码位范围从U+xx0000到U+xxFFFF, 其中xx表示十六进制值从00到10，共计17个平面。第一个平面称为基本多文种平面（Basic Multilingual Plane, BMP），或第零平面（Plane 0）。 其他平面称为辅助平面(Supplementary Planes)。 我们书写html文件在浏览器上预览时可能出现乱码的情况，这时候就要思考以下三者的编码是否一致。 文件保存编码 文件声明编码 浏览器采用编码 参考","tags":[{"name":"综合","slug":"综合","permalink":"http://realwate.com/tags/综合/"}]},{"title":"常用meta标签","date":"2017-03-20T11:14:03.000Z","path":"常用meta标签/","text":"常用meta标签总结1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" /&gt; 忽略将页面中的数字识别为电话号码1&lt;meta name=\"format-detection\" content=\"telephone=no\" /&gt; 移动端123456789101112131415161718192021222324&lt;meta name=\"format-detection\" content=\"telphone=no, email=no\" /&gt;&lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt;&lt;!-- 启用360浏览器的极速模式(webkit) --&gt;&lt;meta name=\"renderer\" content=\"webkit\"&gt;&lt;!-- 避免IE使用兼容模式 --&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;&lt;meta name=\"HandheldFriendly\" content=\"true\"&gt;&lt;!-- 微软的老式浏览器 --&gt;&lt;meta name=\"MobileOptimized\" content=\"320\"&gt;&lt;!-- uc强制竖屏 --&gt;&lt;meta name=\"screen-orientation\" content=\"portrait\"&gt;&lt;!-- QQ强制竖屏 --&gt;&lt;meta name=\"x5-orientation\" content=\"portrait\"&gt;&lt;!-- UC强制全屏 --&gt;&lt;meta name=\"full-screen\" content=\"yes\"&gt;&lt;!-- QQ强制全屏 --&gt;&lt;meta name=\"x5-fullscreen\" content=\"true\"&gt;&lt;!-- UC应用模式 --&gt;&lt;meta name=\"browsermode\" content=\"application\"&gt;&lt;!-- QQ应用模式 --&gt;&lt;meta name=\"x5-page-mode\" content=\"app\"&gt;&lt;!-- windows phone 点击无高光 --&gt;&lt;meta name=\"msapplication-tap-highlight\" content=\"no\"&gt;&lt;!-- 适应移动端end --&gt; seo12345678910&lt;!--页面标题&lt;title&gt;标签(head 头部必须)--&gt;&lt;title&gt;your title&lt;/title&gt;&lt;!--页面关键词 keywords--&gt;&lt;meta name=\"keywords\" content=\"your keywords\"&gt;&lt;!--页面描述内容 description--&gt;&lt;meta name=\"description\" content=\"your description\"&gt;&lt;!--定义网页作者 author--&gt;&lt;meta name=\"author\" content=\"author,email address\"&gt;&lt;!--定义网页搜索引擎索引方式，robotterms 是一组使用英文逗号「,」分割的值，通常有如下几种取值：none，noindex，nofollow，all，index和follow。--&gt;&lt;meta name=\"robots\" content=\"index,follow\"&gt; 优先使用 IE 最新版本和 Chrome1&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" /&gt; viewport模板——通用12345678910111213141516 &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\" name=\"viewport\"&gt; &lt;meta content=\"yes\" name=\"apple-mobile-web-app-capable\"&gt; &lt;meta content=\"black\" name=\"apple-mobile-web-app-status-bar-style\"&gt; &lt;meta content=\"telephone=no\" name=\"format-detection\"&gt; &lt;meta content=\"email=no\" name=\"format-detection\"&gt; &lt;title&gt;标题&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"index.css\"&gt; &lt;/head&gt; &lt;body&gt; 这里开始内容 &lt;/body&gt; &lt;/html&gt;","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"},{"name":"html","slug":"html","permalink":"http://realwate.com/tags/html/"}]},{"title":"restfulAPI","date":"2017-03-20T10:56:49.000Z","path":"restfulAPI/","text":"理念url对应的都是一个资源，我们对资源的操作通过不同的http动词区分,这是restful的核心思想。 如下为经典的restfulAPI展示12345678GET /zoos：列出所有动物园POST /zoos：新建一个动物园GET /zoos/ID：获取某个指定动物园的信息PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）DELETE /zoos/ID：删除某个动物园GET /zoos/ID/animals：列出某个指定动物园的所有动物DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物 可参考Laravel中的restful设计 过滤信息?limit=10：指定返回记录的数量 ?offset=10：指定返回记录的开始位置。 ?page=2&amp;per_page=100：指定第几页，以及每页的记录数。 ?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。 ?animal_type_id=1：指定筛选条件 API认证restful的API一般用与前后端分离的项目中，可采用JWT来认证，后台设置拦截器每次请求检查token，不合法则忽略。 其他在Webstorm可使用restfulClient测试API。在实际开发中可用json-server模拟产生restfulAPI，它会根据需求生成json数据并返回，只需要按照restful的规范去使用即可。","tags":[{"name":"综合","slug":"综合","permalink":"http://realwate.com/tags/综合/"}]},{"title":"浏览器渲染原理及性能优化","date":"2017-03-20T02:21:07.000Z","path":"浏览器渲染原理及性能优化/","text":"主要讲解浏览器的渲染原理，html、css、js之间的依赖对首次渲染时间的影响，性能优化，chrome timeline使用。 浏览器组成先介绍一下浏览器的几大组成部分。 用户界面 渲染引擎渲染引擎是单线程的，除了网络操作以外，几乎所有的事情都在单一的线程中处理，在Firefox和Safari中，这是浏览器的主线程，Chrome中这是tab的主线程。 js引擎单线程，也就是chrome下的v8，firefox下的spidermonkey，渲染引擎与js的操作是互斥的，不可能两个线程同时执行(因为js能改变DOM、CSSOM，会使的渲染结果不同步或者js获得的属性有问题) 网络网络操作由几个并行线程执行，对同一域下并行连接的个数有限制，一般浏览器下为6个。 明确一个概念，js是单线程执行的，但是jsruntime 也就是浏览器是由多个线程组成的，而所谓的eventloop也是浏览器实现的，与js引擎无关。 渲染html步骤 构建DOM树 (ParseHTML 蓝色表示) 浏览器开始解析HTML、svg结构，深度遍历。解析到script标签HTML 解析器会暂停构建 DOM 外部js，则同步下载并执行这段javascript代码。注意：有两步操作，下载 和 执行。如果有async关键字，异步下载js文件，下载完成后就执行，所以执行的顺序不可预测，对于那些不依赖其他js文件 和 DOM状态的可添加此关键字。 如果有defer关键字，立即下载js文件，但会在dom解析完毕即将触发DOMCotentLoad事件时，按照加载顺序执行下载好了的js（事实上却不一定）。等 JavaScript 引擎执行完毕，浏览器从中断的地方恢复 DOM 构建。(预解析优化：当执行脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。并不改变DOM树。)内联js基本一致，仅仅是不需要下载。 如果浏览器尚未完成 CSSOM 下载与构建，而我们就想运行我们的脚本，根据浏览器不同，有不同的策略。Firefox在存在样式表还在加载和解析时阻塞所有的脚本，而Chrome只在当脚本试图访问某些可能被未加载的样式表所影响的特定的样式属性时才阻塞这些脚本。在我们等待时，DOM 构建同样被阻塞。 经实验，在chrome下，下载解析完css做完layout后执行js Chrome Devtool DOM相关事件domLoading： 这是整个过程开始的时间戳，浏览器开始解析 HTML 文档第一批收到的字节 document.domInteractive：标记浏览器完成解析并且所有 HTML 和 DOM 构建完毕的时间点。domContentLoaded：标记 DOM 准备就绪并且没有样式表阻碍 JavaScript 执行的时间点(因为script标签是DOM的一部分，DOM构建完意味着script标签内的js执行完了) - 意味着我们可以开始构建呈现树了。很多 JavaScript 框架等待此事件发生后，才开始执行它们自己的逻辑。因此，浏览器会通过捕获 EventStart 和 EventEnd 时间戳，跟踪执行逻辑所需的时间。domComplete： 顾名思义，所有的处理完成，网页上所有资源（图片等） 下载完成 - 即加载旋转图标停止旋转。loadEvent：作为每个网页加载的最后一步，浏览器会触发onLoad事件，以便触发附加的应用逻辑。devtools使用 构建CSSOM (ParseStyleSheet)css下载到本地后也开始解析。默认情况下，CSS 被视为阻塞渲染的资源(渲染指的是：构造renderTree layout paint composite layer)。HTML 和 CSS 都是阻塞渲染的资源因为构造render树依赖于 DOM 和 CSSOM。 但是依赖程度不同。 DOM只要有一点就能渲染。(可在html中部放入外链script标签，此时浏览器会提前渲染) 如果CSSOM没有构建完毕(尚有在下载的CSS文件)，浏览器不会渲染，同时会阻塞js的执行。可在html头部放入googlecdn的CSS，页面会一直空白，如果这个时候点击停止按钮，会强制浏览器根据已有DOM CSSOM渲染页面。 构建RenderTree(RecalculateStyle)根据输入的 HTML 与 CSS 构建 DOM 树及 CSSOM 树,分别用来描述页面的内容及样式。现在要把他们合并成rendertree了，具体步骤如下。从 DOM 树的根节点开始，遍历每个可见的节点。某些节点完全不可见（例如 script 标签、meta 标签等），因为它们不会在渲染结果中反映，所以会被忽略。给每个可见节点找到相应匹配的 CSSOM 规则，并应用这些规则。Firefox基本上来说是通过CSS 解析 生成 CSS Rule Tree，然后，通过比对DOM生成Style Context Tree，然后Firefox通过把Style Context Tree和其Render Tree（Frame Tree）关联上 布局 (Layout)浏览器 根据rendertree开始布局，布局阶段的输出结果称为 “盒模型”（box model）。盒模型精确表达了窗口中每个元素的位置和大小，而且所有的相对的度量单位都被转化成了屏幕上的绝对像素位置。此刻所有元素的位置都已经确定，只剩下绘制上色了。 绘制 (paint)最后的绘制过程以渲染树为输入参数，实际调用了操作系统底层API，在屏幕上画出每个像素 总结正是因为JavaScript 在 DOM、CSSOM 和 JavaScript 执行间引入了很多新的依存关系，导致浏览器在处理和渲染页面上出现大幅延迟。总结一下。 浏览器渲染原理就是以下几步 DOM-&gt;CSSROM-&gt;RenderTree-&gt;Layout-&gt;Paint-&gt;Compiste 构建DOM是增量构建，渲染引擎一开始会从网络层获取请求文档的内容，通常以8K分块的方式完成,接收到一点就解析一点，如果CSSOM构建完毕，而DOM没完成，是会做增量渲染的，具体的时机由浏览器把控。Chrome有以下几种情况： first paint(绿线)可能在 domContentLoaded(红线)前 进行, 因为大文件会分块解析，如果DOM解析完一块发现所有外链CSS已经下载完成，会构建CSSOM，并渲染出来 外链js会强制触发首次渲染，如果浏览器解析到外部script，会触发firstpaint，这应该是浏览器做的优化 first paint 在 domContentLoaded后执行，因为html文件比较小，将DOM解析完才执行parseStyleSheet。 关联的CSSOM没完成不可能执行渲染以及执行js(chrome有优化)。这样做的原因：1. 没有CSS的页面基本不能看。2. 防止页面出现抖动。3. js获取的值要确定解决方案：1.DOM API动态生成 2. resource preload 3. media指定媒体类型及特性 因为js可能会修改DOM，如果解析html的时候碰到script标签，会停止html的解析，执行js js中访问css时如果样式还不确定，会阻塞js执行。 RenderTree的生成依赖于DOM、CSSOM，浏览器会尽量等待CSSOM构建完成再做首次渲染，但是超过规定时间后还没有构建完毕则直接渲染了。 性能影响当你修改了元素的属性之后，浏览器将会检查为了使这个修改生效是否需要重新计算布局以及更新渲染树reflow：布局被影响，修改rendertree 重新layoutrepaint：背景色等改变，重新绘制。 js操纵DOM性能关键是reflow，每次修改DOM都可能触发reflow。现在的浏览器经过优化后，会把不那么重要的修改放到一个队列中，然后一次性reflow，这又叫增量异步reflow。但是有些情况浏览器是不会这么做的，比如：resize窗口，改变了页面默认的字体，等。对于这些操作，浏览器会马上进行reflow。触发layout判断 参考文章主要参考参考1参考2参考3","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"},{"name":"性能优化","slug":"性能优化","permalink":"http://realwate.com/tags/性能优化/"}]},{"title":"url到页面展示","date":"2017-03-20T02:20:07.000Z","path":"url到页面展示/","text":"一个经典的问题，输入url到页面展示发生了什么。 dns解析向DNS服务器请求，逐级往上递归查询出ip地址，优先查找缓存，缓存存在于浏览器、系统、路由器、DNS服务器 创建tcp连接ip+port确定一条TCP连接如果是http协议，向服务器80端口请求如果是https，则为443端口 发送请求浏览器学名叫UserAgent,根据用户的操作打包成http请求发送给服务器。如果是https，还会进行三次握手，确认服务端的身份是真实的并协商一个用于加密的密钥。http方法putpatchdeleteoptionshead 服务器收到请求物理主机加服务器软件运行在80端口的进程收到请求。根据请求 路径参数 查询参数 http方法 运行代码逻辑 返回页面。 获得html文件浏览器解析html生成DOM碰到js阻塞解析DOM所有的css层叠 来源 特异度 !important 生成CSSOM生成RenderTree-&gt;Layout-&gt;Paint-&gt;CompositeLayer 缓存:Expires: 客户端时间Cache-control:max-age=31500 相对时间强制获取服务器资源可添加时间戳?t= 如果缓存过期lastModified 对比 if-modified-sinceEtag 对比 if-none-match 下载其他资源图片，vedio 差异PC、移动端meta标签框架:zepto Backbone 一图总结 附上参考资料","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"},{"name":"综合","slug":"综合","permalink":"http://realwate.com/tags/综合/"}]},{"title":"初识前端路由","date":"2017-03-17T14:17:49.000Z","path":"初识前端路由/","text":"在SPA中，我们需要在一个页面中管理多个组件，控制他们的位置、显示隐藏等效果，这系列的技术就是前端路由，通过URL的变化来切换组件的状态。 相关API我们都知道，当URL改变时，浏览器的默认动作会触发页面的跳转刷新并向服务器发送请求，如何保证在同一个页面切换url，这就需要知道前端路由的实现细节了。先介绍几个相关的API 使用historyhistory.pushState(obj,title,url);pushState()有三个参数：一个状态对象、一个标题（现在会被忽略），一个可选的URL地址。这是HTML5新增的API，它支持在同域的情况下改变url同时可选的记录一个状态对象，并且页面不会进行跳转。 history.replaceState()操作类似于history.pushState()，不同之处在于replaceState()方法会修改当前历史记录条目而并非创建新的条目。 API参考 window.onpopstate事件与history.pushstate不同，popstate是一个事件，并且挂载在window对象上。popstate只在不会让浏览器页面刷新的历史记录之间切换才能触发(当前页面直接改变url也能)，这些历史记录一般由pushState/replaceState或者是由hash锚点等操作产生。并且在事件的句柄中可以访问状态对象的引用副本 单纯的调用pushState/replaceState并不会触发popstate事件。页面初次加载时，是否会主动触发popstate事件，不同的浏览器实现也不一样 API参考 window.onhashchange事件hash是 URL 中散列标签 (#) 后的那部分。当页面hash(#)变化时，即会触发hashchange。触发的hashchange事件可以访问hash改变前的url和之后的url。同时要注意,它并不会响应pushstate带来的变化 具体实现现在的前端路由在实现上都会使用到已上几个API，根据兼容性的不同选择不同的实现方案。 对于那些支持 pushState/replacestate 的浏览器，直接监听popstate事件，同时用pushstate/replacestate改变url 如果浏览器不能支持 HTML5特性，那么就会监听 onhashchange 事件。 如果浏览器不支持该事件，就只能使用setInterval，每隔一段时间检查url的变化。 总结最后，前端路由不能解决所有问题，比如在页面url改变多次后，用户手动刷新了页面，还是会向后台发送一个请求，这就需要我们在开发的过程中与后台做好沟通，服务器对于默认不能识别的路由返回index页面，我们只要前端做好404页面就行了。","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"}]},{"title":"JWT理解","date":"2017-03-14T07:48:39.000Z","path":"JWT理解/","text":"由于http协议是无状态的(stateless)，服务器是不会记住发送请求的客户端状态信息，而我们在做应用层开发时又需要记住客户的状态，比如登录、购物车等等。通常有以下几种方式实现。 session在客户端第一次发送请求到服务器时，服务器会在内存中开辟一块区域，用于保存客户的状态，同时有一个唯一的session-id，服务器会把这个session-id塞到客户端浏览器的cookie中，由浏览器保存。而cookie对应着一个domain，当浏览器访问该domain时，会自动带上该domain下的cookie，到达服务器后，就能找到本次请求所属的session。实现了在服务端记录了客户机的状态。 这就是传统的web应用逃避HTTP面向无连接的方法 jwtsession的问题： 因为session是保存到服务器上的，在高访问量的情况下，服务器会生出大量session，使服务器性能下降。大型应用还需要借助一些KV数据库和一系列缓存机制来实现session的存储。 session-id是保存到cookie中的，可能会遭到csrf攻击，第三方冒充你的身份访问服务器。 如果是分布式的服务器，需要在多台服务器间同步session 如果是前后端分离的情况，服务端只需要提供一个简单的rest API接口即可，API应该被设计成无状态的。 jwt特点JWT包含了使用.分隔的三部分： Header 头部头部用于描述关于该JWT的最基本的信息，例如其类型以及签名所用的算法等。这也可以被表示成一个JSON对象。1234&#123; &quot;typ&quot;: &quot;JWT&quot;, &quot;alg&quot;: &quot;HS256&quot;&#125; 在这里，我们说明了这是一个JWT，并且我们所用的签名算法（后面会提到）是HS256算法。 Payload 附加信息 12345iss: 该JWT的签发者sub: 该JWT所面向的用户aud: 接收该JWT的一方exp(expires): 什么时候过期，这里是一个Unix时间戳iat(issued at): 在什么时候签发的 Signature 签名对header、payload使用base64编码后，用.连接起来，最后为了防止数据被篡改，我们会使用一个密钥对前面的字符串加密，header的alg字段指明了我们的加密算法，生成签名，添加到jwt的最后。 使用方法使用JWT之后，当用户使用它的认证信息登陆系统之后，会返回给用户一个JWT，用户只需要本地保存该token（通常使用local storage，也可以使用cookie）即可。当用户希望访问一个受保护的路由或者资源的时候，通常应该在 Authorization 头部使用 Bearer 模式添加JWT(即Bearer &lt;token&gt;的形式) 服务端验证方法：服务端的保护路由将会检查请求头 Authorization 中的JWT信息，如果合法，则允许用户的行为。由于JWT是自包含的，因此减少了需要查询数据库的需要。 JWT的这些特性使得我们可以完全依赖其无状态的特性提供数据API服务，甚至是创建一个下载流服务。因为JWT并不使用Cookie的，所以你可以使用任何域名提供你的API服务而不需要担心跨域资源共享问题（CORS）。 应用场景下面是我开发自己博客系统时应用jwt的具体方法(后台express作服务器,前端axios发送请求) 服务端创建一个token 123456789101112var jwt = require('jsonwebtoken') var expiry = new Date(); expiry.setDate(expiry.getDate()+7);//有效期设置为七天 //签名算法 default HS256 let data = &#123; exp:parseInt(expiry.getTime()/1000), extra:info &#125; //这里会对data stringfy后做base64编码，作为payload部分 //并使用指定密钥加密 token = jwt.sign(data,config.JWT_SECRET); 客户端接收处理客户端存储到localstorage，需要payload部分的信息时取出中间部分并base64解码同时转成js对象，如下：JSON.parse(window.atob(token.split(&#39;.&#39;)[1])); 之后客户端每次发送要认证的请求时，带上该token，格式定义为Bearer &lt;token&gt; 1axios.defaults.headers.common['Authorization'] = \"Bearer \"+localStorage.getItem('jwt').replace(/(^\\\")|(\\\"$)/g,'') 最后是服务器端的再次校验 123let authorization = req.headers['authorization'];token = authorization.split(' ')[1]; var decoded = jwt.decode(token, config.JWT_SECRET) decoded为解码出来的js对象，表示payload部分。 OAuth支持两方和三方认证，是目前使用比较广泛的安全认证方式，但对于不使用第三方登录的认证的方式不太适用。 常见的第三方登陆例如QQ、weibo等都是这种方式具体可参见参考参考 参考链接官方地址","tags":[{"name":"综合","slug":"综合","permalink":"http://realwate.com/tags/综合/"}]},{"title":"doctype作用","date":"2017-03-11T13:21:34.000Z","path":"doctype作用/","text":"介绍DOCTYPE的本意是使浏览器按照指定的规范来验证和解析页面，但是现代浏览器仅仅用来不同模式之间的切换，主要有以下几种。 怪异模式(quirks mode)一句话，怪异模式就是为了兼容老旧的页面。因为上古时期的web时代还没有制定统一的w3c标准，所以浏览器厂商如IE、Netscape各自按照自己的规范来做。等到后面w3c标准出后，如果强行遵循w3c的标准来解析渲染，就可能会使web上已存在的页面显示错乱，因此出现了怪异模式。与标准模式的不同主要体现在： 盒子模型的width=border+padding，而标准的width=content-width。 怪异模式会模拟IE，同时CSS解析会比较宽松，例如数字单位可以省略 怪异模式下的input和textarea的默认盒模型将会变成border-box 怪异模式下的文档高度(document.body.client.Height)是窗口可视域的高度近似标准模式(almost standard mode)有限怪异模式和标准模式的唯一区别在于在于对inline元素的行高处理不一样，它是为了解决table中内联图片而设计的。遵循了w3c标准的浏览器，一个块级元素内部的图片下方会出现空隙。如果遵循这种标准，一些table布局的页面图片显示就会有问题。因此定义了近似标准模式。在怪异模和有限怪异模式下，为了计算行内子元素的最小高度，一个块级元素的行高必须被忽略 标准模式(standard mode)即w3c制定的标准 如何触发如果XHTML文档包含形式完整的doctype，则以一般标准模式呈现。对于html4.0.1文档，包含严格DTD的doctype以标准模式呈现页面，包含过渡DTD和URI的doctype以标准模式呈现页面，但是有过渡DTD没有URI则以混杂模式呈现。Doctype不存在或者行事不正确则以混杂模式呈现 如何判断console 使用window.top.document.compatMode12css1Compat //标准模式BackCompat //混杂模式 参考资料1参考资料2","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"},{"name":"html","slug":"html","permalink":"http://realwate.com/tags/html/"}]},{"title":"使用MongoDB","date":"2017-03-10T11:41:18.000Z","path":"使用MongoDB/","text":"最近接触了MongoDB，和平常的关系数据库使用方法不大一样，特此记录。 下载并安装MongoDB新建\\data\\db文件(设置数据库文件位置)后 启动MongoDB服务mongod –dbpath D:\\mongodb\\data\\db 连接服务mongo默认端口 27017 注册成系统服务启动配置创建配置文件 mongod.configdbpath=D:\\software\\MongoDB\\data\\dblogpath=D:\\software\\MongoDB\\data\\log\\mongod.log 注册为系统服务 以管理员身份运行mongod –config D:\\software\\MongoDB\\mongod.config –install –serviceName “MongoDB” 查看结果services.msc 启动和停止服务net start MongoDBnet stop MongoDB 移除mongod –removesc delete MongoDB 命令行使用在cmd输入mongo查看数据库：show dbs; 新建表：db.createCollection(‘要新建的表名’); 查看当前数据库的表： show collections; 删除当前数据库指定表：db.表名.drop(); 删除当前数据库：db.dropDatabase(); 一个表中字段不一定都要相同 新建 并 转到firstdb数据库use fristdb 添加数据people是集合(表) 文档(一条记录)db.people.insert({“name”:”张龙豪”,”age”:18})db.albums.insert([{title:’旧日足迹’},{title:’Parachutes’}]) db.people.insertMany([{“name”:”张龙豪”,”age”:18},]) 更新数据db.表名.update({“条件字段名”:”字段值”},{$set:{“要修改的字段名”:”修改后的字段值”}});db.people.update({“age”:18},{“age”:20}) 删除数据db.people.remove({“age”:20}) 查询数据查询表中所有数据：db.表名.find(); 按条件查询（支持多条件）：db.表名.find(条件); 查询第一条（支持条件）：db.表名.findOne(条件); 限制数量：db.表名.find().limit(数量); 跳过指定数量：db.表名.find().skip(数量);","tags":[{"name":"教程","slug":"教程","permalink":"http://realwate.com/tags/教程/"}]},{"title":"git整理","date":"2017-03-10T10:09:20.000Z","path":"git整理/","text":"记录git的一些基础、原理知识. 几个核心概念工作区、暂存区，版本库，它们的关系可以用下面两张图表示。 同时要注意，工作区的文件有两种状态，即已经纳入版本控制的跟踪文件和未跟踪文件。工作区到暂存区的过程可由下图表示。 这个认识很关键，git不会改动那些未跟踪的文件，git reset、git checkout都不会修改、覆盖未跟踪的文件。 一些理解HEAD 与分支每次commit,git都会记录下文件快照同时生成两个对象：一个树对象（ 记录着目录结构和 blob 对象索引） 以及一个提交对象（ 包含着指向前述树对象的指针和所有提交信息。Git 的分支，其实本质上仅仅是指向提交对象的可变指针,仅包含所指对象校验和(长度为 40 的 SHA-1 值字符串)同时，还有一个HEAD指向当前所在分支，可以理解成当前分支的别名。 1git branch testing` 会在当前提交对象上创建一个testing指针。 1234$ git log --oneline --decoratef30ab (HEAD, master, testing) add feature #32 - ability to add new34ac2 fixed bug #1328 - stack overflow under certain conditions98ca9 initial commit of my project 上面的命令表示当前 master 和 testing分支均指向校验和以 f30ab开头的提交对象。 1git checkout branchname 可用于切换分支，这条命令做了两件事 一是使 HEAD 指回 master 分支 二是将工作目录恢复成 master 分支所指向的快照内容。 分支切换会改变你工作目录中的文件，相当于git reset 远程跟踪分支是远程分支状态的引用。它们以 (remote)/(branch) 形式命名，可以这么理解，远程仓库在本地有一个特殊的分支 git clone相当与git fetch当抓取到新的远程跟踪分支,在本地生成origin/master分支，同时git checkout -b master origin/master在远程分支的基础上创建本地master分支，等同于git checkout --track origin/serverfix git reset 和 git checkoutgit checkout 用法12git checkout -- CONTRIBUTING.mdgit checkout HEAD-- CONTRIBUTING.md 检出版本库文件，它会以版本库的文件为基准，如果工作区存在一样的文件进行覆盖，如果不存在则添加，除此之外不会改动工作区。 git reset1234git reset HEAD~&lt;num&gt; &lt;-soft/-hard&gt;git reset HEAD &lt;filename&gt;git reset --hard HEAD^版本回退到上一个 本地仓库git reset --hard 3628164 git reset本质是移动HEAD指针，同时可选的改变暂存区或者工作区，不同于git checkout，它会直接用版本库的文件覆盖掉所有工作区的跟踪文件。经历reset后，git log显示的commit记录也会撤销，可以用git reflog查找commit git merge 和 git rebase这个其实就是两种不同的合并策略，在两个分支分叉的时候，merge会做三方合并，而rebase会将要合并的分支里提交的改变移到当前分支里重放一遍。 gitconfig专门用来配置或读取相应的工作环境变量。而正是由这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方： /etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 –system 选项，读写的就是这个文件。 ~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 –global 选项，读写的就是这个文件。 当前项目的 Git 目录中的配置文件（也就是工作目录中的 .git/config文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。 在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件 常用配置名称和邮件地址12git config --global user.name &quot;John Doe&quot;$ git config --global user.email johndoe@example.com 区分大小写1git config --global core.ignorecase false 其他 常用.gitignore文件列表 进入","tags":[{"name":"综合","slug":"综合","permalink":"http://realwate.com/tags/综合/"}]},{"title":"https","date":"2017-03-10T02:11:12.000Z","path":"关于https/","text":"关于htpps，一直认为只是在http的基础上做了一层加密，今天在网上看了很多资料、博客，发现没有想象中的那么简单，特此记录。 总的来说https是为了解决以下三个基本问题。 通信内容的保密性 通信内容的完整性 通信对方的真实性下面分别说下我的理解。 保密性毫无疑问，这是https最基本的功能，因为http自身是明文传输，所有的内容都直接能被查看到，因此必须对通信内容加密来实现保密性。最大的问题是：在不安全的http环境基础下，如何实现可靠的加密传输 这里有有必要谈及常用的两种加密方式，非对称加密和对称加密。 对称加密很简单，加密解密用的密钥都是同一个。对称内容加密强度非常高，一般破解不了。但存在一个很大的问题就是无法安全地生成和保管密钥。假如客户端软件和服务器之间每次会话都使用固定的，相同的密钥加密和解密，肯定存在很大的安全隐患。如果有人从客户端端获取到了对称密钥，整个内容就不存在安全性了，而且管理海量的客户端密钥也是一件很复杂的事情。 非对称加密非对称加密有两把钥匙，分别是公钥和私钥，它具体的加密原理涉及到数学知识，我们只需要知道公钥加密的内容只能通过私钥解密，反之亦然同样的非对称加密也有他的缺点： 它的加密解密运算量非常大，十分消耗CPU资源，影响性能。 对加密内容的长度有限制，不能超过公钥长度。比如现在常用的公钥长度是 2048 位，意味着待加密内容不能超过 256 个字节。正因为非对称加密的特性，使得它一般用来做密钥交换或者内容签名，而不是应用层传输内容的加解密。 综上，结合两者的优缺点，现有的htpps采用非对称加密来加密对称密钥即SSL在握手过程中使用非对称密码算法来协商密钥，实际使用对称加解密的方法对http内容加密传输。浏览器和服务器每次新建会话时都使用非对称密钥交换算法协商出对称密钥，使用这些对称密钥完成应用数据的加解密和验证，整个会话过程中的密钥只在内存中生成和保存，而且每个会话的对称密钥都不相同（除非会话复用），中间者无法窃取。具体的加密及密钥协商过程如下图所示 引用阮一峰老师的文章，解释如下 第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程。 真实性这里说的真实性，指的是你访问的服务器是真正的站点而不是假冒的。这里就涉及到我们通常说的证书这个概念。如同我们人一样，我们会使用身份证来证明自己的身份，而服务器为了证明自己的身份，需要一个第三方权威机构来出具证明，这就是CA，而它颁发的证明就是证书。证书里面包含了真实服务器的公钥和网站的一些其他信息，数字证书机构用自己的私钥加密来进行认证确保是可信赖的CA机构。 证书也有可能伪造，而验证证书真实性和完整型的过程正是使用了非对称加密和hash签名。浏览器专门有一套验证证书的规则，它会逐级向上验证证书的颁发者，如果最终是CA根证书，则该证书可信赖。根证书机构可能会受权给底下的中级证书机构，然后由中级证书机构颁发中级证书，多级证书，网站证书和根证书之间所有的中间证书都需要被验证。保证证书被某个根证书信任、证书上绑定的域名和该网站的域名一致、证书没有过期，否则浏览器就会暂停握手过程 完整性完整性指的是保证服务器传来的数据是完整的，没有被第三方篡改实现起来也很简单，每次发送数据前双方都用一个约定好的hash函数计算内容的hash值，生成数字签名，并用私钥加密。这也是是非对称加密的一种应用场景。即使有人破解了内容，也无法修改内容，因为没有私钥来加密hash签名。 总结最后我对https做一个总结非对称加密的前提保证私钥安全性。确保建立、协商对称密钥的过程不能被第三方知道，否则接下来进行的对称加密通信的数据就可能被破解。用非对称加密传输约定好的对称加密密钥，在这个过程中，把非对称加密的公钥传到客户端时，通过证书的形式，客户端负责验证证书的真实性，同时通过数字签名来保证证书的完整性，数字签名是经过私钥加密的。 补充生成证书的步骤：一般我们只需要证明自己是某个域名的所有者，然后填写有关信息，交给CA进行数字签名，用CA私钥加密认证，即可生成证书。相关的信息称之为待签名证书内容(to be signed certificate )这部分包含了 10 个要素，分别是版本号，序列号，签名算法标识，发行者名称，有效期，证书主体名，证书主体公钥信息，发行商唯一标识，主体唯一标识，扩展等。 https与中间人攻击对于大部分https网站，都是有被 Man-in-the-MiddleAttack 的风险的首先无论PC还是手机 内部都是有一个受信的CA列表的，所以无论是够是真的受信，只要在这个列表里面都无条件信任 如果某些受信CA 乱签发证书，可以被利用劫持https回话 如果装了某些apps 或者软件，同时导入了一些自签发的CA，同样可能被劫持 https与流量劫持这种技术一般称为sslstrip，它的本质就是阻止与真实服务器建立ssl连接 黑客为了绕过HTTPS，采用了SSL层剥离的技术，黑客阻止用户和使用HTTPS请求的网站之间建立SSL连接使用户和代理服务器（攻击者所控服务器）之间使用了未加密的HTTP通信同样的技术还可通过DNS劫持做到，将用户要访问的域名定向到恶意的站点，从而发起攻击。这些技术的本质其实都类似。","tags":[{"name":"综合","slug":"综合","permalink":"http://realwate.com/tags/综合/"}]},{"title":"https参考资料","date":"2017-03-09T12:39:24.000Z","path":"https参考资料/","text":"csr: 证书签发请求(Certificate Signing Request)CA在csr文件上数字签名使得攻击者不能伪造和篡改证书，有些地方签名后的文件后缀是crt，要申请证书的用户先填写相关信息后生成csr文件在线生成 将csr提交给权威CA，经过签名后生成crt证书(可查看内容为pem格式，在iis tomcat下要求密钥与证书打包存放，所以需要转换格式)。 也可自签名证书用于测试 自签名证书生成 服务器类型：Apache，IIS，Nginx，Tomcat， other Server。就是说，ssl证书时按照这几种类型生成对应不同文件格式的证书。部署在tomcat上时，要把crt+key转成jks格式主流数字证书格式 第一步，从key和crt生成pkcs12格式的keystore openssl pkcs12 -export -in mycert.crt -inkey mykey.key -out mycert.p12 -name tomcat -CAfile myCA.crt -caname root -chain 第二步 keytool工具支持PKCS12与JKS之间相互转换,生成tomcat需要的keystore keytool -importkeystore -v -srckeystore tomcat.pfx -srcstoretype pkcs12 -srcstorepass 123456 -destkeystore tomcat.keystore -deststoretype jks -deststorepass 123456 还可以直接用JDK自带的keytool工具一键生成tomcat证书 keytool -genkeypair -alias &quot;tomcat&quot; -keyalg &quot;RSA&quot; -keystore &quot;D:\\tomcat.keystore&quot; 最后在tomcat等服务器上配置证书即可，tomcat如下配置 &lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot; maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; scheme=&quot;https&quot; secure=&quot;true&quot; clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot; keystoreFile=&quot;D:/tomcat.keystore&quot; keystorePass=&quot;123456&quot;/&gt; web.xml 配置http跳转https &lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;sslapp&lt;/web-resource-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;http-method&gt;GET&lt;/http-method&gt; &lt;http-method&gt;POST&lt;/http-method&gt; &lt;/web-resource-collection&gt; &lt;user-data-constraint&gt; &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt; &lt;/user-data-constraint&gt; &lt;/security-constraint&gt; 云盾免费证书 Mozilla证书 startSSL 证书格式参考 格式转换https参考","tags":[{"name":"参考资料","slug":"参考资料","permalink":"http://realwate.com/tags/参考资料/"}]},{"title":"CSS总结篇(五)","date":"2017-03-09T07:32:50.000Z","path":"CSS总结篇-五/","text":"本篇内容有 前端工程化，css方法论 前端工程化 css basereset 设置浏览器默认样式normalize 类似reset 但会保留浏览器默认样式variable components组件样式 pages每个页面单独的样式 原则 dry 面向对象 oocss .btn(基本结构) .btn-primary(继承)结构 皮肤分离 容器 内容分离 元素本身决定自己的表现.header .btn{} 单一职责 开闭原则不直接修改.content .box 命名不要太具体，扩展性差bem规范 block__element–modifiermodifier 继承并对基础的样式修饰 或部分修改 CSS预处理器 less sass stylus已上扩展了css 能编译css支持 css变量嵌套mixin 混入公共代码封装成函数 原生@import 多个http请求 性能不好使用sass的 继承 postcss 使用下一代css标准插件机制stylelintautoprefixercssnext 常用网站css优先级查询生成渐变阴影生成时间函数css属性大全程序员文档大全 一些细节 关于offsetoffsetWidth offsetHeight 是border-box的宽高offsetLeft 元素border-box外层 到 offsetParent border-box外层如果parent是body会加上body到html的距离，因为body的offsetParent为null（此时的parent可以认为html）因此通过递归获取页面元素偏移，最后不会计算到html的margin，需要手动加上html的margin。参考 offset border-radius 作用在border-box上，如果border-width 比border-radius大，则内面没有圆角效果,原理就是拿一个椭圆/圆去切割一个角，如果超出border-box长度,浏览器会按比例缩小 当 border-radius 的值为 10px / 5px 20px 时， 其效果相当于 10px 10px 10px 10px / 5px 20px 5px 20px。 可以用背景色transparent border-radius针对设置border实现特殊效果 absolute相对padding-box定位 background 一些特殊的百分比值：margin paddingbackground-positiontranslate()vertical-align","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"},{"name":"css","slug":"css","permalink":"http://realwate.com/tags/css/"}]},{"title":"CSS总结篇(四)","date":"2017-03-09T07:32:49.000Z","path":"CSS总结篇-四/","text":"本篇内容有 布局,动画，响应式 布局float两栏布局 float + bfcbfc不与浮动重叠 默认100%width 升级版（两栏可互换）外层容器预留paddingwidth100%是可变内容容器 固定宽度容器 定位处理 或 margin设置为负值 伪等高效果高度由content-box决定padding 很大 使得有背景margin负值消除padding影响 positionabsolute 脱离文档流 元素布局时不会考虑这种元素 inline-block table布局td border问题 设置border-collapse设置 td width相当于 min-width当设置了宽度时 如果给定的宽度不够，会等比缩放使用table-layout :fixed 使宽度不够时不缩放 不要使用表格标签布局使用dispaly:table table-cell table-row等获得表格能力两栏布局 table-cell做导航栏 table-cell 鼠标hover效果使用hsl颜色 vertical-align在line-box指定垂直对齐方式table-cell中 垂直居中 flex 专门为解决布局问题而生的规范实现两栏布局 很简单 flex容器内display无效了 flex元素 flex-grow 0 占满剩余空间的比例根据剩余空间宽度 然后按照grow比例分配 flex-shrink 1根据flex-basis算出多出来的长度 进行加权分配 宗周 只有从上到下 从左到右align itemaign selfalign-content 多行 order优先级 grid二维网格布局 动画transform布局与positionrelative一致transform-origintranslate rotate scale 3d变换perspective 视距作用在父级元素 使子元素具有3d效果 transition 状态变化添加过渡效果transition-property duration timingfunction delay时间函数 animation实现更加复杂的样式变化效果定义关键帧 响应式设计同一页面适配不同大小屏幕viewport 使pc页面显示在手机上 设置img max-width margin padding百分比值 相对于包含块的宽度定义因而可设置 保持宽高比padding-top：50% display:inline-blocktext-align:justify #####大面积布局 使用 媒体查询@media all speech print 打印的样式@media screen 默认显示的屏幕样式link引入 添加media= 条件 按需引入 @media 媒体特性device-widthdevice-pixel-ratio &gt;2 高分辨率 图片处理orientation 横屏幕 竖屏 字体：使用 remmedia设置root 兼容性 浏览器支不支持使用can i use 了解市场份额百度统计 替代方案等同效果js替代方案 @supports 检查是否支持属性。但是该属性自身有兼容性 层叠 后面的覆盖前面的，添加浏览器私有前缀 autoprefixer css online ie独有 条件注释 属性名加*的hack js检测navigator.userAgent添加Class ie6 - ie9 针对选择器浏览器私有前缀 测试https://www.browserstack.com/ polyfill 垫片对于浏览器不支持的特性 使用代码模拟实现标准效果","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"},{"name":"css","slug":"css","permalink":"http://realwate.com/tags/css/"}]},{"title":"CSS总结篇(三)","date":"2017-03-09T07:32:48.000Z","path":"CSS总结篇-三/","text":"本篇内容有 定位，浮动,堆叠顺序 定位模式 常规流(除去根元素 浮动 绝对定位的元素都在normal-flow中) 浏览器进行布局时只考虑normal-flow bfc(块级格式化上下文) 因为BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。 从上到下摆放 同一bfc内 垂直margin合并 行级格式化上下文 特性： 包容浮动元素 高度包含浮动元素 清除内部浮动 不会和浮动元素重叠 absolute float inline-block oveflow 创建 作用：清除浮动 margin折叠问题 双栏布局 生成条件： 根元素 属性不为none position为absolute或fixed display为inline-block, table-cell, table-caption, flex, inline-flex overflow不为visible 浮动 脱离文档流 浮动元素不会影响块级盒 但会影响行级盒子 影响bfc (margin有效) 不论摆放位置在哪里 行级元素 and float元素自身margin有效 在包含容器内 content-box内浮动 clear指定元素哪一边不能与之前的浮动框 相邻 浮动元素 clearfix::after{} 相当于 在浮动元素最后面 添加了一个正常的元素 类似划了一道分割线 非浮动元素前面添加before clear:both; 绝对定位 定位 堆叠position 常规流布局static 默认定位值 relative 常规流相对自己原来位置定位 absolute 相对非static祖先元素 元素变为inline-blockleft top 都相对于 paddingbox初始在content-box坐上角 fixed 相对视口定位 z-index只对定位元素有效（css3中 display:flex 子元素下 z-index也有效）非static元素 即为定位元素默认auto 负数 正数 元素的堆叠顺序只是相关于其堆叠上下文。z-index比较必须在同一堆叠上下文比较才有意义。堆叠上下文生成条件：html根元素z-index不为auto auto可以看成0 但不会创建上下文设置了某些css3属性 opacity transform animation等 堆叠顺序 (在一个堆叠上下文中) background (层叠上下文元素的边框和背景色) z-index&lt;0 常规块级元素 浮动元素 行级元素 inline-block和inline 有效的(定位元素，flex子元素，堆叠上下文元素) z-index auto/0 有效的(定位元素，flex子元素) z-index&gt;0 一旦普通元素具有了层叠上下文，其层叠顺序就会变高。 这里需要分两种情况讨论： 如果层叠上下文元素不依赖z-index数值，则其层叠顺序是z-index:auto可看成z:index:0级别；z-index:auto 有效如果层叠上下文元素依赖z-index数值，则其层叠顺序由z-index值决定。 如果是同一堆叠顺序，遵循后来居上. css3新的形成堆叠上下文条件： z-index值不为auto的flex项(父元素display:flex|inline-flex). 元素的opacity值不是1. 元素的transform值不是none. 元素mix-blend-mode值不是normal. 元素的filter值不是none. 元素的isolation值是isolate. will-change指定的属性值为上面任意一个。 元素的-webkit-overflow-scrolling设为touch 总结：堆叠上下文元素，以及内部的堆叠顺序。参考 css media 媒体类型","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"},{"name":"css","slug":"css","permalink":"http://realwate.com/tags/css/"}]},{"title":"CSS总结篇(二)","date":"2017-03-09T07:32:47.000Z","path":"CSS总结篇-二/","text":"本篇内容有 css盒模型,文本排列 盒模型content padding border margin 四层盒子正常流中：块级元素7大水平值=父元素width，距离错误则重置margin-right垂直设置marginauto =设置为0垂直外边距合并 top-bottom合并 top-top合并 width 百分比 content-boxheight 100%依赖 响应式布局min-width max-width（没有内容先撑高）min-height max-height(内容少自适应) padding margin 垂直外边距合并问题 保证换行间距一致定义 多远的距离内不能有盒子负值：允许重叠多少 boxsizing:border-box*｛boxsizing:inherit｝ border: width style colorborder-left top制作三角形 overflow:auto(需要滚动条才出现) scroll(一定有滚动条) hidden visibleoveflow-x overflow-y viewport 视口通过窗户看风景 块级元素 一定是标签 display:block;table 生成块级盒子 方方正正可包含多个块级 或 行级 子元素同时包含块级和行级是 行级 生成匿名块级盒子 行级元素会生成生成行级盒子(inline-box) 可分布多行的margin top bottom 无作用padding top bottom 不影响布局（line-height影响）文字全部被行级盒子包裹 匿名行级盒子 生成步骤如下： 如果是inline元素，font-size设置的是em框的大小。line-height减去font-size 平均分配到 font上下，这就是inline-box，高度实际上就等于line-height值，宽度等于元素内容区宽度 替换元素如inline-block imginline-box不考虑line-height 只在百分比vertical-align才有用高度等于margin border padding 同时inline-box组成line-box，指的是一行的box模型inline-box的最高和最低确定整个line-box的高度 vertical-align可能会改变inline-box位置 间接改变line-box值有以下几种： 长度 通过距离升高（正值）或降低（负值）元素。’0cm’等同于’baseline’ 百分值 – % 通过距离（相对于1line-height1值的百分大小）升高（正值）或降低（负值）元素。’0%’等同于’baseline’ baseline 默认。元素的基线与父元素的基线对齐。基线定义为：正常元素x的底部。 sub 降低元素的基线到父元素合适的下标位置。 super 升高元素的基线到父元素合适的上标位置。 top 把对齐的子元素的顶端与line box顶端对齐。 text-top 把元素的inline-box顶端与父元素内容区域的顶端对齐。与默认的baseline元素的 文字顶部对齐 middle 元素的中垂点与 父元素的基线加1/2父元素中字母x的高度 对齐。 bottom 把对齐的子元素的底端与line box底端对齐。 text-bottom 把元素的底端与父元素内容区域的底端对齐。 inherit 采用父元素相关属性的相同的指定值。 行级盒子内的子盒子行级 可以包含块级盒子时分离行级 并用匿名块级盒子包裹 display:blocknonevisibility = opacity:0; generated content多生成盒子a::before a::after content:’’ atttr() ‘’ 文本 font-family 按字符匹配 按定义顺序匹配 通用字体族 抽象 形体基本一致 serif衬线体 san-serif线条基本一致 monospace 等宽字体 英文放在中文前 最后添加通用字体族别 font-size 初始默认16px em相对于自身font-size 斜体 粗体 font-size 指定em框大小而em框 有字体设计者确定，不一定恰好装下一个字符 font-style normal italic(斜体的字体，没有用算法算出) oblique(算法得出) font-weight 100-900 400normal 700bold line-height 继承问题(继承计算值) em会计算出来再继承 font 书写 斜体 粗体 大小/行高 family web font(css3) @font-face{ src:local(),url() //具有优先级 } google fonts 英文 google字体库 font-spider 中文 text-align(html dir决定初始值) justify 最后一行没有用 letter-spacing word-spacing text-indent text-decoration:underine strike-line white-space:指定空白符如何处理 normal(内容超出 从空格换行) nowrap(不换行) pre(类似pre) 若white-space=normal，若有长单词碰到空格才会换行 此时可设置 word-break (指定是否允许在单词中间换行) break-word 特别长的单词换行 break-all (强制换行) 颜色 colorrrs rgba 设置颜色 opacity设置元素的不透明度 hsl 色相0-360 饱和度 亮度0-100% hsla 易于调节同一色系！ 排版细节baseline x-height line box内的摆放规则按照基线对齐vartical-alignmiddle x-height/2top bottom 不固定 p内的img下面有空隙浏览器根据strut确定基线 lidisplay:list-item csstoolsbox-shadow 多个多重阴影box-radius 四个值 /分开水平 垂直制作icon","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"},{"name":"css","slug":"css","permalink":"http://realwate.com/tags/css/"}]},{"title":"CSS总结篇(一)","date":"2017-03-09T07:32:46.000Z","path":"CSS总结篇-一/","text":"本篇内容有 css用法，层叠优先级，求值策略，选择器 使用css简单的来说，css规则由两部分组成，一个选择器表示该规则涉及到的html元素，以及一组属性集合，定义了具体的规则内容。我们有如下三种方式使用css。 外部样式表单独维护一个CSS文件，将html与css分离，一般我们都建议用这种方式引入CSS. 1&lt;link rel=\"stylesheet\" href=\"style.css\" type=\"text/css\"&gt; 内部样式表 与外部样式表相比，他没有增加http请求开销，但是它不能在多个html文件之间共享样式如果大量使用，还会使得html文件过于臃肿，不利维护。 1234567&lt;style&gt; h1 &#123; color: blue; background-color: yellow; border: 1px solid black; &#125;&lt;/style&gt; 内联 在html标签中使用style=，绝大多数情况我们都不会写这种形式的css，我曾经在这些情况下写过，现在看来其实是可以避免的。 css内容很短(应该定义成简短的class代替) 为了获得高优先级的css(使用高特异度避免) 使用javascript修改css。css优先级查询!important style id class tag * inherit 层叠 css翻译过来就是层叠样式表，不同的css规则会进行层叠，规则如下 看css的来源开发者样式 &gt;用户样式 &gt; 浏览器样式 &gt;默认样式 相同来源的css比较他们的特异度。*特异度为0 ，继承无特异度 。 !important 用户 &gt; 开发者 求值策略指定值 (specified value) 可通过以下三种途径获得 如果指定了(可以是我们设置或浏览器默认)，即为指定的值 如果未指定看是否有继承，继承计算值。 默认为 initial，CSS规范指定了每个属性的初始值。 计算值 (computed value)该值为浏览器不进行布局所能得到的最具体的值，用于继承。通常包括将相对值转换成绝对值(如 em 单位或百分比)。如 width:60%; 应用值 (used value)CSS 属性的应用值（used value）是完成所有计算后最终使用的值，可以由 window.getComputedStyle 获取 计算出CSS属性的最终值有三个步骤。首先，指定值specified value 取自样式层叠 (选取样式表里权重最高的规则), 继承 (如果属性可以继承则取父元素的值)，或者默认值。然后，按规范算出 计算值computed value (例如， span 指定 position: absolute 后display 变为 block)。最后，计算布局(尺寸比如 auto 或 百分数 换算为像素值 )， 结果即 应用值used value。这些步骤是在内部完成的，脚本只能使用 window.getComputedStyle 获得最终的应用值。(构建CSSOM，层叠，求值) 选择器属性选择器 [for~=’height’] 空格隔开含有height *= 有就行 class=”icon-heart” [class^=”icon-“] 高级选择器:target伪类锚点指定到元素时的样式 :lang针对语言写样式 :lang(fr) :nth-child(an+b)选中子元素 n从0开始 可进行组合 odd even:nth-of-type first-child last-child :not(selector) 排除符合selector的元素 :only-child 只有一个儿子:only-of-type 只有一个类型 :empty空内容 伪元素 虚拟的元素::first-line ::first-letter h2+p 兄弟选择器 紧挨h2的ph2~p 同级 跟h2同级的p checked 伪类 a:link visited hover active focus 组合形式 p.class","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"},{"name":"css","slug":"css","permalink":"http://realwate.com/tags/css/"}]},{"title":"CSS总结篇 - 开篇","date":"2017-03-09T07:32:45.000Z","path":"CSS总结篇-开篇/","text":"前端的基础有三部分组成，html，css，js，其中在学习中最让我感到困惑的就是css。 起因按理来说，css只是一些声明式的规则，我们只需要知道每个属性值的作用就可以认为已经掌握了该属性。但，真的是这样吗。我常常认为自己已经掌握某个属性值，在实践中却发现没那么简单。 这些属性亦可以称为css的坑吧。 以z-index为例，在w3school上找到如下解释 z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素, 仅能在定位元素上奏效. 很简单，决定元素在z轴上的堆叠顺序，且只针对定位元素也就是position不为static的元素。于是我开始使用。忽然有一天，我发现一段类似如下代码12345678910111213141516171819202122div&#123; position: relative; &#125;.d1&#123; width:100px; height: 100px; background: gray; z-index: 0;&#125;.d1-1&#123; width: 50px; height: 50px; background: royalblue; z-index: 999;&#125;.d2&#123; width: 100px; height: 100px; top: -60px; background: green; z-index: 1;&#125; 12345678910&lt;div class=\"d1\"&gt; z-index:0 &lt;div class=\"d1-1\"&gt; z-index:999 &lt;/div&gt;&lt;/div&gt;&lt;div class=\"d2\"&gt; z-index:1&lt;/div&gt; 显示结果如下z-index:999的元素居然在z-index:1的下面，在数个浏览器上尝试，结果都一样。我开始怀疑人生。。经过一番折腾，我收集到了了如下知识点元素的堆叠顺序只是相关于其堆叠上下文。因此z-index比较必须在同一堆叠上下文比较才有意义。 而常见的堆叠上下文生成条件有以下几种 html根元素 z-index不为auto 设置了某些css3属性 opacity ,transform等 因此z-index:999的元素不能直接与z-index:1的元素比较，要用与之同级的父元素z-index:0去比较，自然父元素d1在d2下方。 随着学习的深入，我们还会了解到在一个堆叠上下文中，有七层堆叠顺序，flex 子元素设置z-index也有效等等(后文会专门提到，不再详述)。我们发现，自以为知道的属性用法只是冰山一角，一个z-index属性牵扯到的知识点有一大把。 类似这样的属性还有多少？谁知道呢。唯一确定的是每多踩一个坑，我所不知道的暗坑就会少一个。在知乎问题为什么你会觉得 CSS 难学下的回答都很好。借鉴里面的部分回答以及我自身的感受，总结一下我对css的看法吧。 总的来说，由于css要解决的问题过于复杂，所以css中其中隐含了许多潜规则，很多属性之间会相互作用，从软件工程的的角度说，属性与属性之间互相依赖产生耦合，这是不利于实践开发的，很多后端转前端的人都会有点难适应。 当然css并不是一门编程语言，简单的说只是一个DSL,所有的css规则在规范中都有解释，很多规则是贯穿整个体系的,等熟练了就会发现有套路可循。学习css不能套用学习编程语言的那一套，要用感性的心态去理解，多试多练，踩得坑多了自然也就懂了。为了总结css的部分基础知识以及记录我踩过或我知道的那些坑,我写了以下系列博客(抽空更新中…)。 CSS总结篇(1) CSS总结篇(2) CSS总结篇(3) CSS总结篇(4) CSS总结篇(5)","tags":[{"name":"前端","slug":"前端","permalink":"http://realwate.com/tags/前端/"},{"name":"css","slug":"css","permalink":"http://realwate.com/tags/css/"}]},{"title":"使用hexo","date":"2017-03-08T07:32:45.000Z","path":"使用hexo/","text":"准备工作 先在github上创建我们博客对应的repository，仓库名为用户名.github.io 安装hexo脚手架cnpm i hexo-cli -g用于生成一个nodejs项目，包括hexo所必需的目录结构及相关依赖 初始化并安装依赖 12hexo initcnpm i 以上，基于hexo的项目环境已经搭建完毕，下面开始写博客啦~ 使用 命令行hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面 直接编写 文章在 source/_posts目录下，可直接使用markdown语法编写。 如果想修改头像可以直接在主题的 _config.yml 文件里面修改，友情链接，之类的都在这里， 修改名字在 public/index.html 里修改 主题可下载到themes目录，并修改项目根路径下的_config.yml 引用图片，方法有以下几种 使用本地路径：在hexo/source目录下新建一个img文件夹，将图片放入该文件夹下，插入图片时使用markdown语法，链接即为/img/图片名称。 如果使用hexo3，设置_config.yml中的post_asset_folder:truecnpm install https://github.com/CodeFalling/hexo-asset-image --save完成安装后用hexo new新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹，图片就可以放在文件夹下面。具体引用方式： 123&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_img example.jpg This is an example image %&#125; 使用云图片CDN，引用在线地址，如七牛 生成（主要就是两个命令） hexo g#在public目录下生成静态文件 hexo s#启动本地服务，进行文章预览调试 发布 安装发布所需依赖cnpm install hexo-deployer-git -S 因为要发布到github，必须已经进行ssh认证，使用ssh -T git@github.com查看是否认证。具体认证方法可网上搜索。 配置根目录下的_config.yml1234deploy: type: git repository: git@github.com:Realwate/Realwate.github.io.git branch: master ``` 推送到githubhexo d 上传public目录hexo d -g 直接一步 生成并上传 其他 _config.yml配置 每项冒号后面都加一个空格，另外不要出现tab title: 博客主页标题 url: 你的博客网址，例如http://yoursite.com permalink: 每篇文章的URL链接格式，例如:year/:month/:title/，注意不要漏掉最后的/ date_format: 每篇文章日期的格式，如YYYY-MM-DD会显示2014-01-01，具体格式设置方法参考moment.js per_page: 每页显示的文章数量详细可查看文档 在文章中加一个 &lt;!--more--&gt;， &lt;!--more--&gt;后面的内容就不会显示出来了 填写文章头部这块的tags能自动对文章分类 更多主题可查看。关于主题的使用问题，可查看相关主题的github issue markdown高亮需要标注对应语言，具体可参考 参考1","tags":[{"name":"教程","slug":"教程","permalink":"http://realwate.com/tags/教程/"}]}]